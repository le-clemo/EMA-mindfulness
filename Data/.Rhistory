rm(list = ls()) #clean all up
#setwd("C:/Users/cleme/Documents/Education/RUG/Thesis/EMA-mindfulness/Data/ESM/mindcog_v202202-2")
setwd("~/Documents/RUG/Thesis/EMA-mindfulness/Data/ESM/mindcog_v202202-2")
library(readxl)
library(tidyverse)
library(plyr)
library(dplyr)
library(Hmisc)
library(corrplot)
library(data.table)
library(ggplot2)
library(reshape)
library(ggpubr)
library(lubridate)
library(igraph)
library(qgraph)
#read in data
data <- read_xlsx('mindcog_db_2022-02-14.xlsx')
#################################### Data clean up ####################################
#drop unnecessary columns
data <- subset(data, select = -c(roqua_id, hide_pii_from_researchers, gender, birth_year,
hide_values_from_professionals, respondent_label, respondent_type,
mindcog_db_project, mindcog_db_notes, mindcog_db_location,
mindcog_db_invited_at, mindcog_db_emailed_at, mindcog_db_variant,
mindcog_db_anonymous))
#turn all ids to lower case for easier error handling below
data$id <- tolower(data$id)
#fix various errors in id column
for(row in 1:nrow(data)) { #some "s" are missing
if( ! (grepl("s", data$id[row], fixed=TRUE)) & (!(is.na(data$id[row])))){
data$id[row] <- paste("s", data$id[row], sep = "")
}
if( ! (grepl("_g", data$id[row], fixed=TRUE))){ #some "_" prior to "g" are missing
data$id[row] <- sub("g", "\\1_g", data$id[row])
}
if( ! (grepl("_m", data$id[row], fixed = TRUE))){ #some "_" prior to "m" are missing
data$id[row] <- sub("m", "\\1_m", data$id[row])
}
if( (grepl("meting", data$id[row], fixed = TRUE))){#some had "meting" instead of just "m"
data$id[row] <- sub("meting", "\\1m", data$id[row])
}
}
missing_data <- ddply(data, .(patient_id, id, group, intervention), plyr::summarise,
numBeeped = length(mindcog_db_open_from),
responseRate = round((numBeeped - length(unique(mindcog_db_non_response)))/numBeeped,2))
na_data <- missing_data[(is.na(missing_data$patient_id)) |
is.na((missing_data$group)) |
is.na((missing_data$intervention)), ]
#write.csv(na_data, file = "patientID_issues.csv")
#convert excel na to R na and remove respondents without group (for now)
#data[data=="#N/A"] = NA
#drop subjects without an assigned group
data <- drop_na(data, group)
data <- drop_na(data, patient_id)
#unique(data$id)
#add block (1 = first intervention cycle, 2 = second intervention cycle)
data$block <- NA
for(row in 1:nrow(data)) {
if((grepl("m1", data$id[row], fixed = TRUE)) | (grepl("m2", data$id[row], fixed = TRUE))){
data$block[row] <- 1
} else {
data$block[row] <- 2
}
}
#test <- subset(data, select = c(id, phase, block))
#add new column "subject" -> extract all characters up until the first underscore in column "id"
data$subject <- str_extract(data$id, regex("^[^_]+(?=_)"))
#Changing ESM item names
#Get numbers of ESM item columns
item1 <- which( colnames(data)=="mindcog_db_1" ) #this is the first column that interests us
item33 <- which( colnames(data)=="mindcog_db_33" )#last item of interest
colNamesOld <- setNames(data.frame(colnames(data[, item1:item33])), "columns")
colNamesNew <- c('firstEntry', 'sleepQuality', 'toBedHour', 'toBedMinute', 'trySleepHour', 'trySleepMinute',
'durationFallAsleep', 'wakeupHour', 'wakeupMinute', 'restednessWakeup', 'wakeful',
'sad', 'satisfied', 'irritated', 'energetic', 'restless', 'stressed', 'anxious',
'listless', 'thinkingOf', 'worried', 'stickiness', 'thoughtsPleasant',
'thoughtsTime', 'thoughtsValence', 'thoughtsObject', 'distracted',
'restOfDayPos', 'aloneCompany', 'companyPleasant', 'alonePleasant', 'posMax',
'posIntensity', 'negMax', 'negIntensity', 'comments')
setnames(data, old = colNamesOld$columns, new = colNamesNew)
#################################### Initial analyses  ####################################
#Convert dates from characters to datetimes
data[['mindcog_db_open_from']] <- as.POSIXct(data[['mindcog_db_open_from']],
format = "%d/%m/%Y %H:%M")
data[['mindcog_db_started_at']] <- as.POSIXct(data[['mindcog_db_started_at']],
format = "%d/%m/%Y %H:%M")
data[['mindcog_db_completed_at']] <- as.POSIXct(data[['mindcog_db_completed_at']],
format = "%d/%m/%Y %H:%M")
#calculate the time it took a participant to start after being informed (in minutes)
data$response_delay <- (data$mindcog_db_started_at - data$mindcog_db_open_from)/60
#calculate how long it took a participant to complete the questionnaire (in minutes)
data$response_duration <- (data$mindcog_db_completed_at - data$mindcog_db_started_at)/60
#calculate the minutes that have past since the last beep
subject_IDs <- unique(data$subject) #get a list of all unique IDs
data$minLastBeep <- NA
for(id in subject_IDs){ #for loop to fill the column with the day numbers
prev_row = 0
xDate <- as.Date("01/01/1999", format = '%d/%m/%Y') #low arbitrary date for comparison of first assessment date
respondent_rows <- which(data$subject == id) #row indices of rows associated with respondent
for (row in respondent_rows) { #loop over these rows
#if this rows date is greater than the previous assessment's date
if(as.Date(data$mindcog_db_open_from[row]) == as.Date(xDate)){
timePast = hms(as.ITime(data$mindcog_db_open_from[row]) - as.ITime(data$mindcog_db_open_from[prev_row]))
minutesPast = hour(timePast)*60 + minute(timePast) #increment the assessment day count
data$minLastBeep[row] <- minutesPast #add the minutes past
prev_row = row #update the previous row index (not plus one bc numbers are not continuous!)
xDate = data$mindcog_db_open_from[row] #set new comparison date to date of current row
} else {
#otherwise this row's date is equal to the previous row's --> same assessment day
data$minLastBeep[row] <- NA
prev_row = row
xDate = data$mindcog_db_open_from[row] #set new comparison date to date of current row
}
}
}
#test <- subset(data, select = c(id, subject, mindcog_db_open_from, minLastBeep))
#group by respondent_id and count the number on nonresponses
participant_responses <- ddply(data, .(subject), plyr::summarise,
numBeeped = length(mindcog_db_open_from),
noResponse = length(unique(mindcog_db_non_response)),
response = numBeeped - noResponse,
responseRate = round(response/numBeeped,2))
#the mean response rate is ~65%
meanResponseRate <- mean(participant_responses$responseRate)
#sd of 23.46
sdResponseRate <- sd(participant_responses$responseRate)
#################################### Beep number, assessment day and lagged variables  ####################################
#adding beep number (continuous count of sent assessment queries)
data$beepNum <- NA
for(id in subject_IDs){ #every participant
respondent_rows <- which(data$subject == id) #row indices of rows associated with respondent
#adding a number per assessment
data[respondent_rows,]$beepNum <- 1:length(respondent_rows)
}
#beep number per phase
data$phaseBeepNum <- NA
phases <- unique(data$phase)
for(id in subject_IDs){ #every participant
for(phase in phases){
phase_rows <- which((data$subject == id) & (data$phase == phase)) #row indices of rows associated with respondent
if(length(phase_rows) > 0){
data[phase_rows,]$phaseBeepNum <- 1:length(phase_rows)
}
}
}
#beep number per block
data$blockBeepNum <- NA
for(id in subject_IDs){ #every participant
for(block in 1:2){
block_rows <- which((data$subject == id) & (data$block == block)) #row indices of rows associated with respondent
if(length(block_rows) > 0){
data[block_rows,]$blockBeepNum <- 1:length(block_rows)
}
}
}
#test <- subset(data[data$subject == "s8",], select = c(subject, phase, block, blockBeepNum, phaseBeepNum, beepNum))
#adding assessment day
data$assessmentDay <- NA #adding an empty column for assessment days
for(id in subject_IDs){ #for loop to fill the column with the day numbers
assessment_day <- 0
prev_row = 0
xDate <- as.Date("01/01/1999", format = '%d/%m/%Y') #low arbitrary date for comparison of first assessment date
respondent_rows <- which(data$subject == id) #row indices of rows associated with respondent
for (row in respondent_rows) { #loop over these rows
#if this rows date is greater than the previous assessment's date
if(as.Date(data$mindcog_db_open_from[row]) > xDate){
assessment_day = assessment_day + 1 #increment the assessment day count
data$assessmentDay[row] <- assessment_day #and add this new number as assessment day for this row
prev_row = row #update the previous row index (not plus one bc numbers are not continuous!)
xDate = as.Date(data$mindcog_db_open_from[row]) #set new comparison date to date of current row
} else {
#otherwise this row's date is equal to the previous row's --> same assessment day
data$assessmentDay[row] <- data$assessmentDay[prev_row]
prev_row = row
}
}
}
#test <- subset(data, select = c(id, subject, mindcog_db_open_from, assessmentDay))
#assessment day per block
data$blockAssessmentDay <- NA #adding an empty column for assessment days
for(id in subject_IDs){ #for loop to fill the column with the day numbers
for(block in 1:2){
assessment_day <- 0
prev_row = 0
xDate <- as.Date("01/01/1999", format = '%d/%m/%Y') #low arbitrary date for comparison of first assessment date
block_rows <- which((data$subject == id) & (data$block == block)) #row indices of rows associated with respondent
if(length(block_rows) > 0){
for (row in block_rows) { #loop over these rows
#if this rows date is greater than the previous assessment's date
if(as.Date(data$mindcog_db_open_from[row]) > xDate){
assessment_day = assessment_day + 1 #increment the assessment day count
data$blockAssessmentDay[row] <- assessment_day #and add this new number as assessment day for this row
prev_row = row #update the previous row index (not plus one bc numbers are not continuous!)
xDate = as.Date(data$mindcog_db_open_from[row]) #set new comparison date to date of current row
} else {
#otherwise this row's date is equal to the previous row's --> same assessment day
data$blockAssessmentDay[row] <- data$blockAssessmentDay[prev_row]
prev_row = row
}
}
}
}
}
rm(list = ls()) #clean all up
setwd("C:/Users/cleme/Documents/Education/RUG/Thesis/EMA-mindfulness/Data") #/ESM/mindcog_v202204
#setwd("~/Documents/RUG/Thesis/EMA-mindfulness/Data/ESM/mindcog_v202204")
library(tidyverse)
library(plyr)
library(dplyr)
library(data.table)
library(ggplot2)
library(itsadug)
library(mgcv)
library(tidyr)           # Simplify R code
library(car)
library(MASS)
R.version.string
#read in data
data <- read.csv('merged_data.csv')
###########################################################################################################
######################################### Some more data prep #############################################
###########################################################################################################
#same for sleepQuality
for(id in unique(data$subject)){
respondent_rows <- which(data$subject == id)
current_day <- 0
for(row in respondent_rows){
if((data$assessmentDay[row] != current_day) & (!is.na(data$sleepQuality[row]))){
sleep_quality <- data$sleepQuality[row]
current_day <- data$assessmentDay[row]
} else if((data$assessmentDay[row] == current_day) & (is.na(data$sleepQuality[row]))){
data$sleepQuality[row] <- sleep_quality
}
}
}
#same for sleepDuration
for(id in unique(data$subject)){
respondent_rows <- which(data$subject == id)
current_day <- 0
for(row in respondent_rows){
if((data$assessmentDay[row] != current_day) & (!is.na(data$sleepDuration[row]))){
sleep_duration <- data$sleepDuration[row]
current_day <- data$assessmentDay[row]
} else if((data$assessmentDay[row] == current_day) & (is.na(data$sleepDuration[row]))){
data$sleepDuration[row] <- sleep_duration
}
}
}
#and for sleepLatency
for(id in unique(data$subject)){
respondent_rows <- which(data$subject == id)
current_day <- 0
for(row in respondent_rows){
if((data$assessmentDay[row] != current_day) & (!is.na(data$sleepLatency[row]))){
sleep_latency <- data$sleepLatency[row]
current_day <- data$assessmentDay[row]
} else if((data$assessmentDay[row] == current_day) & (is.na(data$sleepLatency[row]))){
data$sleepLatency[row] <- sleep_latency
}
}
}
#aaaaaaand for restednessWakeup
for(id in unique(data$subject)){
respondent_rows <- which(data$subject == id)
current_day <- 0
for(row in respondent_rows){
if((data$assessmentDay[row] != current_day) & (!is.na(data$restednessWakeup[row]))){
restedness <- data$restednessWakeup[row]
current_day <- data$assessmentDay[row]
} else if((data$assessmentDay[row] == current_day) & (is.na(data$restednessWakeup[row]))){
data$restednessWakeup[row] <- restedness
}
}
}
data$group <- factor(data$group, levels = c("controls", "remitted"))
data$intervention <- factor(data$intervention, levels = c("mindfulness", "fantasizing"))
data$phase <- factor(data$phase, levels = c("pre", "peri"))
data$grInt <- as.factor(paste(data$group, data$intervention, sep = "."))
data$blockPhase <- as.factor(paste(data$phase, data$block, sep = "."))
data$grIntPhase <- as.factor(interaction(data$group, data$intervention, data$phase, drop = TRUE))
data$subject <- as.factor(data$subject)
data$subjB <- interaction(data$subject, data$block, drop = TRUE)
data$thoughtsTime <- factor(data$thoughtsTime, levels = c("past", "present", "future"))
data$thoughtsValence <- factor(data$thoughtsValence, levels = c("negative", "neutral", "positive"))
data$aloneCompany <- factor(data$aloneCompany, levels = c("alone", "in company"))
#add day of the week
data$weekday <- weekdays(strptime(data$mindcog_db_open_from, "%Y-%m-%d %H:%M:%S"))
data$weekday <- as.factor(data$weekday)
###########################################################################################################
############################################ Scaling Data #################################################
###########################################################################################################
#creating variables minus baseline means per subject
met.vars <- c('ruminating', 'stickiness', 'sumNA',  'down', 'irritated', 'restless', 'anxious',
'sumPA', 'wakeful', 'satisfied', 'energetic',
'stressed', 'listless',  'distracted',
'thoughtsPleasant', 'restOfDayPos', 'companyPleasant', 'alonePleasant',
'posMax', 'posIntensity', 'negMax', 'negIntensity',
"sleepQuality", "sleepLatency", "sleepDuration", "restednessWakeup")
#in addition we create a new list which includes both the changed and unchanged met.vars for scaling later on
scale.vars <- c(rep(NA, length(met.vars)*3))
i = 0
for(v in met.vars){
new_var <- paste(v, "_diff", sep = "")
data[[new_var]] <- NA
gam_var <- paste(v, "_gam", sep = "")
data[[gam_var]] <- NA
i = i+1
scale.vars[[i]] <- v
i = i+1
scale.vars[[i]] <- new_var
i = i+1
scale.vars[[i]] <- gam_var
for(id in unique(data$subject)){
for(b in 1:2){
pre_rows <- which((data$subject == id) & (data$phase=="pre") & (data$block==b))
peri_rows <- which((data$subject == id) & (data$phase=="peri") & (data$block==b))
s_rows <- which((data$subject == id) & (data$block==b))
baselineMean <- mean(data[[v]][pre_rows], na.rm=TRUE)
if(is.na(baselineMean)){
baselineMean <- 0
}
data[[new_var]][s_rows] <- round(data[[v]][s_rows] - baselineMean, 2)
data[[gam_var]][pre_rows] <- NA
data[[gam_var]][peri_rows] <- round(data[[v]][peri_rows] - baselineMean, 2)
}
}
}
# View(subset(data[which(data$subject=="s37"),],
#             select = c("subject", "phase", "block", "ruminating", "ruminating_gam", "ruminating_diff", "beepNum")))
#creating a scaled version of data
sc_data <- copy(data)
sc_data[scale.vars] <- scale(sc_data[scale.vars])
#number of participants so far
length(unique(sc_data$subjB)) #66 subjB (same subject, different block --> viewed as separate)
responses_block <- ddply(sc_data, .(subjB), plyr::summarise,
numCompleted = length(mindcog_db_open_from),
noResponse = length(unique(mindcog_db_non_response)),
response = numCompleted - noResponse,
responseRate = round(response/numCompleted,2),
numDays = max(assessmentDay))
meanResponseRate_block <- mean(responses_block$responseRate) #the mean response rate is ~67.6%
length(unique(responses_block[which(responses_block$responseRate >= meanResponseRate_block),]$subjB)) #36
length(unique(responses_block[which(responses_block$responseRate >= 0.6),]$subjB)) #45
length(unique(responses_block[which(responses_block$responseRate >= 0.5),]$subjB)) #53
responses_subject <- ddply(sc_data, .(subject), plyr::summarise,
numCompleted = length(mindcog_db_open_from),
noResponse = length(unique(mindcog_db_non_response)),
response = numCompleted - noResponse,
responseRate = round(response/numCompleted,2),
numDays = max(assessmentDay))
meanResponseRate_subject <- mean(responses_subject$responseRate) #the mean response rate is ~66.9%
length(unique(responses_subject[which(responses_subject$responseRate >= meanResponseRate_block),]$subject)) #20
length(unique(responses_subject[which(responses_subject$responseRate >= 0.6),]$subject)) #26
length(unique(responses_subject[which(responses_subject$responseRate >= 0.5),]$subject)) #33
#removing participants with a response rate lower than 60%
pp <- unique(responses_block[which(responses_block$responseRate >= 0.6),]$subjB)
sc_data <- sc_data[which(sc_data$subjB %in% pp),]
#sc_data <- sc_data[which(sc_data$blockBeepNum <= 140),]
#sc_data <- sc_data[which(is.na(sc_data$mindcog_db_non_response)),]
###########################################################################################################
######################################## Predicting rumination ############################################
###########################################################################################################
#checking out its distribution
hist(data$ruminating, breaks = 20)
qqnorm(data$ruminating)
qqline(data$ruminating)
#also the change scores
hist(data$ruminating_diff, breaks = 20)
qqnorm(data$ruminating_diff)
qqline(data$ruminating_diff) #change scores are more normally distributed
avg2 <- ddply(sc_data, c("group", "intervention", "phaseBeepNum", "ruminating_gam"), summarise,
N    = length(ruminating_gam),
sd   = sd(ruminating_gam),
se   = sd / sqrt(N))
plot2 <- ggplot(avg2, aes(y=ruminating_gam, x=phaseBeepNum, color=intervention)) +
geom_point(position = position_jitter(w=0.1,h=0))+ facet_grid(.~group) +
ylab("Rumination Difference peri-pre")+ xlab("Phase Assessment Number") + labs(color = "Intervention") +
geom_hline(yintercept=0) + geom_smooth()  #+ scale_x_discrete(limits=c("1","2","3", "4", "5", "6", "7"))
plot2
gam1 <- bam(ruminating_gam ~ s(phaseBeepNum) + group * intervention +
s(companyPleasant_gam) +
s(sumNA_gam) + s(sumPA_gam) + ti(sumNA_gam, sumPA_gam) +
s(negIntensity_gam) + s(posIntensity_gam) + ti(negIntensity_gam, posIntensity_gam) +
s(stickiness_gam) + s(distracted_gam) + s(listless_gam) + s(sleepQuality_gam) +
s(phaseBeepNum, by = subject, bs="fs", m=1),
data = sc_data)
load("models_rumination/gam1.rda")
View(summary_gam1)
summary_gam1
plot_smooth(gam1, view="phaseBeepNum", rug=F, plot_all="intervention", main="Change in rumination peri-intervention")
plot_smooth(gam1, view="phaseBeepNum", rug=F, plot_all="group")
#plot the model based predicted differences between interventions (summed effects)
plot_parametric(gam1, pred=list(intervention=c("mindfulness", "fantasizing")))
#and between groups
plot_parametric(gam1, pred=list(intervention=c("mindfulness", "fantasizing"), group=c("controls", "remitted")))
#,main="mindfulness vs fantasizing")
plot_diff(gam1, view="phaseBeepNum", comp=list( group=c("controls", "controls"), intervention=c("mindfulness", "fantasizing")))
# plot differences
plot_diff(gam1, view="phaseBeepNum", comp=list("intervention"=c("mindfulness", "fantasizing")), main="mindfulness vs fantasizing")
plot_diff(gam1, view="phaseBeepNum", comp=list( group=c("remitted", "remitted"), intervention=c("mindfulness", "fantasizing")))
plot_smooth(gam1, view="phaseBeepNum", rug=F, plot_all=c("intervention", "group"), main="Change in rumination peri-intervention")
?plot_smooth
plot_smooth(gam1, view="phaseBeepNum", rug=F, cond=list(group="remitted"), plot_all=c("intervention", "group"), main="Change in rumination peri-intervention")
plot_smooth(gam1, view="phaseBeepNum", rug=F, cond=list(group="remitted"), plot_all=c("intervention"), main="Change in rumination peri-intervention")
plot_smooth(gam1, view="phaseBeepNum", rug=F, cond=list(group="remitted"), plot_all=c("intervention", "group"), main="Change in rumination peri-intervention")
plot_smooth(gam1, view="phaseBeepNum", rug=F, cond=list(group="remitted"), plot_all=c("intervention", "group"), main="Change in rumination peri-intervention - remitted group")
plot_smooth(gam1, view="phaseBeepNum", rug=F, cond=list(group="remitted"), plot_all=c("intervention", "group"), main="Change in rumination peri-intervention")
plot_smooth(gam1, view="phaseBeepNum", rug=F, cond=list(group="controls"), plot_all=c("intervention", "group"), main="Change in rumination peri-intervention")
load("models_na/na.m1.rda")
View(summary_na.m1)
summary_na.m1
plot_smooth(na.m1, view="phaseBeepNum", rug=F, cond=list(group="remitted"), plot_all=c("intervention", "group"), main="Change in rumination peri-intervention")
plot_smooth(na.m1, view="phaseBeepNum", rug=F, cond=list(group="controls"), plot_all=c("intervention", "group"), main="Change in rumination peri-intervention")
#plot the model based predicted differences between interventions (summed effects)
plot_parametric(na.m1, pred=list(intervention=c("mindfulness", "fantasizing")))
#and between groups
plot_parametric(na.m1, pred=list(intervention=c("mindfulness", "fantasizing"), group=c("controls", "remitted")))
avg2 <- ddply(sc_data, c("group", "intervention", "phaseBeepNum", "sumPA_gam"), summarise,
N    = length(sumPA_gam),
sd   = sd(sumPA_gam),
se   = sd / sqrt(N))
plot2 <- ggplot(avg2, aes(y=sumPA_gam, x=phaseBeepNum, color=intervention)) +
geom_point(position = position_jitter(w=0.1,h=0))+ facet_grid(.~group) +
ylab("Positive Affect Difference peri-pre")+ xlab("Phase Assessment Number") + labs(color = "Intervention") +
geom_hline(yintercept=0) + geom_smooth()  #+ scale_x_discrete(limits=c("1","2","3", "4", "5", "6", "7"))
plot2
load("models_na/pa.m1.rda")
summary_pa.m1
plot_smooth(pa.m1, view="phaseBeepNum", rug=F, cond=list(group="remitted"), plot_all=c("intervention", "group"), main="Change in rumination peri-intervention")
plot_smooth(pa.m1, view="phaseBeepNum", rug=F, cond=list(group="controls"), plot_all=c("intervention", "group"), main="Change in rumination peri-intervention")
#plot the model based predicted differences between interventions (summed effects)
plot_parametric(pa.m1, pred=list(intervention=c("mindfulness", "fantasizing")))
#and between groups
plot_parametric(pa.m1, pred=list(intervention=c("mindfulness", "fantasizing"), group=c("controls", "remitted")))
load("models_stickiness/sticky.m1.rda")
summary_sticky.m1
plot_smooth(pa.m1, view="phaseBeepNum", rug=F, cond=list(group="remitted"), plot_all=c("intervention", "group"), main="Change in rumination peri-intervention")
plot_smooth(pa.m1, view="phaseBeepNum", rug=F, cond=list(group="controls"), plot_all=c("intervention", "group"), main="Change in rumination peri-intervention")
plot_smooth(sticky.m1, view="phaseBeepNum", rug=F, cond=list(group="remitted"), plot_all=c("intervention", "group"), main="Change in stickiness peri-intervention")
plot_smooth(sticky.m1, view="phaseBeepNum", rug=F, cond=list(group="controls"), plot_all=c("intervention", "group"), main="Change in stickiness peri-intervention")
#plot the model based predicted differences between interventions (summed effects)
plot_parametric(sticky.m1, pred=list(intervention=c("mindfulness", "fantasizing")))
#and between groups
plot_parametric(sticky.m1, pred=list(intervention=c("mindfulness", "fantasizing"), group=c("controls", "remitted")))
plot_smooth(na.m1, view="phaseBeepNum", rug=F, cond=list(group="remitted"), plot_all=c("intervention", "group"), main="Change in negative affect peri-intervention")
plot_smooth(na.m1, view="phaseBeepNum", rug=F, cond=list(group="controls"), plot_all=c("intervention", "group"), main="Change in negative affect peri-intervention")
plot_smooth(pa.m1, view="phaseBeepNum", rug=F, cond=list(group="remitted"), plot_all=c("intervention", "group"), main="Change in positive affect peri-intervention")
plot_smooth(pa.m1, view="phaseBeepNum", rug=F, cond=list(group="controls"), plot_all=c("intervention", "group"), main="Change in positive affect peri-intervention")
?mgm
library(mgm)
?mgm
?bootnet::mgm
?bootnet
library(bootnet)         # Network stability        # Simplify R code
?bootnet
?bootnet_mgm
?netSimulator

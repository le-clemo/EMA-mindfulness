boxplot(new_df$logfrq ~ new_df$nchar, main = "Relation between logFrq and nChar",
xlab = "Number of characters", ylab = "Log Frequency")
frq_df <- aggregate(new_df$logfrq, list(new_df$nchar), FUN = mean)
lines(x = frq_df$Group.1, y = frq_df$x, col = "red", lwd = 2.3)
#Creating boxplot to compare nchar with logfrq
boxplot(new_df$logfrq ~ new_df$nchar, main = "Relation between logFrq and nChar",
xlab = "Number of characters", ylab = "Log Frequency")
frq_df <- aggregate(new_df$logfrq, list(new_df$nchar), FUN = median)
lines(x = frq_df$Group.1, y = frq_df$x, col = "red", lwd = 2.3)
#Calculating frequencies using tapply
tapply(alice, INDEX = alice, FUN = length) #the output is an array
#Calculating frequencies using tapply
tapply(alice, INDEX = alice, FUN = sum) #the output is an array
#install.packages("rmarkdown", repos="http://cran.us.r-project.org")
#install.packages("languageR")
library(languageR)
library(rmarkdown)
data(alice)
#help(alice)
alice <- alice[grepl("^[a-zA-Z]+$", alice)]
dim(alice)
dim(alice)
data(alice)
dim(alice)
alice <- alice[grepl("^[a-zA-Z]+$", alice)]
dim(alice)
#Assignment 2
#Create sineWave function
sineWave <- function(x, a=1, b=1, c=0){
y <- a * sin(b*x) + c
return(y)
}
#create a sequence of 100 numbers from 0 to 7
my_seq = seq(from = 0, to = 7, length.out = 100)
y <- sineWave(my_seq)
#plot the sine wave
plot(my_seq, y, main = "SineWave Function", xlab = "x", ylab = "y", type = "b"
, pch = 16, col = "blue", ylim = c(-1.5, 1))
abline(h = 0)
abline(v = pi, lty = 2)
abline(v = 2*pi, lty = 2)
#changing parameter "a"
y2 <- sineWave(my_seq, a = .5) #parameter a changes the magnitude of the y values
lines(my_seq, y2, col = "red", pch = 16, type = "b")
#changing parameter "b"
y3 <- sineWave(my_seq, b = .5)
lines(my_seq, y3, col = "green", pch = 16, type = "b")
#changing parameter "c"
y4 <- sineWave(my_seq, c = -.5)
lines(my_seq, y4, col = "grey", pch = 16, type = "b")
set.seed(123) # to make sure the random numbers are always the same
n <- 25
x <- rep(seq(from = 0, to = 1.5*pi, length.out = 10), n) # generate n sequences with 10 equal-distance numbers from 0 to 1.5*pi;
# use the functions rep and seq
a <- rnorm(n, sd = .25) # generate n random numbers using the function rnorm.
simdat <- data.frame( x = x,
a = rep(a,each=10),
Trial = rep(1:n, each=10),
Simulation=1)
simdat$y <- sineWave(simdat$x, a= simdat$a)
plot(simdat$x[simdat$Trial == 1], simdat$y[simdat$Trial == 1], main = "SineWave Functions", xlab = "x", ylab = "y", type = "b"
, pch = 16, col = "blue", xlim = c(0, 5.5))
abline(h = 0)
abline(v = pi, lty = 2)
for (j in 2:n) {
lines(simdat$x[simdat$Trial == j], simdat$y[simdat$Trial == j], col = "red")
#print("line plotted")
}
a <- rnorm(n, mean = 1, sd = 1) # generate n random numbers using the function rnorm.
simdat2 <- data.frame( x = x,
a = rep(a,each=10),
Trial = rep(1:n, each=10),
Simulation=2)
simdat2$y <- sineWave(simdat2$x, a = simdat2$a)
simdatM <- rbind(simdat, simdat2)
avg_y = aggregate(simdatM$y ~ simdatM$Simulation + simdatM$x, FUN = mean)
plot(avg_y$`simdatM$x`[avg_y$`simdatM$Simulation` == 1], avg_y$`simdatM$y`[avg_y$`simdatM$Simulation` == 1], main = "SineWave Functions", xlab = "x", ylab = "y", type = "b"
, pch = 16, col = "blue", xlim = c(0, 5.5), ylim = c(-1, 1))
abline(h = 0)
abline(v = pi, lty = 2)
lines(avg_y$`simdatM$x`[avg_y$`simdatM$Simulation` == 2],
avg_y$`simdatM$y`[avg_y$`simdatM$Simulation` == 2], col = "red")
legend(x = 4.5, y = 1, legend=c("Line 1", "Line 2"),
col=c("blue", "red"), lty=1)
legend(x = 4, y = 1, legend=c("Line 1", "Line 2"),
col=c("blue", "red"), lty=1)
?legend
simdat <- data.frame( x = x,
a = rep(a,each=10),
Trial = rep(1:n, each=10),
Simulation=1)
simdat$y <- sineWave(simdat$x, a= simdat$a)
plot(simdat$x[simdat$Trial == 1], simdat$y[simdat$Trial == 1], main = "SineWave Functions", xlab = "x", ylab = "y", type = "b"
, pch = 16, col = "blue", xlim = c(0, 5.5))
abline(h = 0)
abline(v = pi, lty = 2)
for (j in 2:n) {
lines(simdat$x[simdat$Trial == j], simdat$y[simdat$Trial == j], col = "red")
}
set.seed(123) # to make sure the random numbers are always the same
n <- 25
x <- rep(seq(from = 0, to = 1.5*pi, length.out = 10), n) # generate n sequences with 10 equal-distance numbers from 0 to 1.5*pi;
# use the functions rep and seq
a <- rnorm(n, sd = .25) # generate n random numbers using the function rnorm.
simdat <- data.frame( x = x,
a = rep(a,each=10),
Trial = rep(1:n, each=10),
Simulation=1)
simdat$y <- sineWave(simdat$x, a= simdat$a)
plot(simdat$x[simdat$Trial == 1], simdat$y[simdat$Trial == 1], main = "SineWave Functions", xlab = "x", ylab = "y", type = "b"
, pch = 16, col = "blue", xlim = c(0, 5.5))
abline(h = 0)
abline(v = pi, lty = 2)
for (j in 2:n) {
lines(simdat$x[simdat$Trial == j], simdat$y[simdat$Trial == j], col = "red")
}
View(simdatM)
View(simdatM)
actr.B <- function(a, b, d = .5){
log(sum((b-a)**-d))
}
actr.B(c(1,25,35,100),110)
act.plot <- function(n){
plot(x=0,y=0,
main="Baselevel activation",
ylab="Act",xlab="Sec",type="n",
xlim=c(0,200),ylim=c(-1.5,1.5))
abline(h=0)
references <- sort(trunc(runif(n,0,200)))
yi = rep(NA,length = 200) #create list of NA values
i = 1
for(ti in 1:200){
yi[i] <- actr.B(references[references < ti], ti)
i <- i+1
}
lines(x = c(1:200), y = yi, lwd = 2)
abline(v=references, col = "red", lty = 2)
}
set.seed(123) # seed set to be able to reproduce the two plots. this
act.plot(n = 20)
act.plot <- function(n){
plot(x=0,y=0,
main="Baselevel activation",
ylab="Act",xlab="Sec",type="n",
xlim=c(0,200),ylim=c(-1.5,1.5))
abline(h=0)
references <- sort(trunc(runif(n,0,200)))
yi = rep(NA,length = 200) #create list of NA values
for(ti in 1:200){
yi[ti] <- actr.B(references[references < ti], ti)
}
lines(x = c(1:200), y = yi, lwd = 2)
abline(v=references, col = "red", lty = 2)
}
set.seed(123) # seed set to be able to reproduce the two plots. this
act.plot(n = 20)
actr.B(c(1,25,35,100),110, d = .2)
actr.B(c(1,25,35,100),110, d = .4)
set.seed(123) # to make sure the random numbers are always the same
n <- 25
x <- rep(seq(from = 0, to = 1.5*pi, length.out = 10), n) # generate n sequences with 10 equal-distance numbers from 0 to 1.5*pi;
# use the functions rep and seq
a <- rnorm(n, sd = .25) # generate n random numbers using the function rnorm.
simdat <- data.frame( x = x,
a = rep(a,each=10),
Trial = rep(1:n, each=10),
Simulation=1)
simdat$y <- sineWave(simdat$x, a= simdat$a)
plot(simdat$x[simdat$Trial == 1], simdat$y[simdat$Trial == 1], main = "SineWave Functions", xlab = "x", ylab = "y", type = "b"
, pch = 16, col = "blue", xlim = c(0, 5.5))
abline(h = 0)
abline(v = pi, lty = 2)
for (j in 2:n) {
lines(simdat$x[simdat$Trial == j], simdat$y[simdat$Trial == j], col = "red")
}
a <- rnorm(n, mean = 1, sd = 1) # generate n random numbers using the function rnorm.
simdat2 <- data.frame( x = x,
a = rep(a,each=10),
Trial = rep(1:n, each=10),
Simulation=2)
simdat2$y <- sineWave(simdat2$x, a = simdat2$a)
simdatM <- rbind(simdat, simdat2)
avg_y = aggregate(simdatM$y ~ simdatM$Simulation + simdatM$x, FUN = mean)
plot(avg_y$`simdatM$x`[avg_y$`simdatM$Simulation` == 1], avg_y$`simdatM$y`[avg_y$`simdatM$Simulation` == 1], main = "SineWave Functions", xlab = "x", ylab = "y", type = "b"
, pch = 16, col = "blue", xlim = c(0, 5.5), ylim = c(-1, 1))
abline(h = 0)
abline(v = pi, lty = 2)
for (j in 2:n) {
lines(simdat$x[simdat$Trial == j], simdat$y[simdat$Trial == j], col = "red")
}
lines(avg_y$`simdatM$x`[avg_y$`simdatM$Simulation` == 2],
avg_y$`simdatM$y`[avg_y$`simdatM$Simulation` == 2], col = "red")
legend(x = 4, y = 1, legend=c("Line 1", "Line 2"),
col=c("blue", "red"), lty=1)
simdat2 <- data.frame( x = x,
a = rep(a,each=10),
Trial = rep(1:n, each=10),
Simulation=2)
simdat2$y <- sineWave(simdat2$x, a = simdat2$a)
simdatM <- rbind(simdat, simdat2)
avg_y = aggregate(simdatM$y ~ simdatM$Simulation + simdatM$x, FUN = mean)
View(simdatM)
rm(list = ls()) #clean all up
#setwd("C:/Users/cleme/Documents/Education/RUG/Thesis/EMA-mindfulness/Data/ESM/mindcog_v202202-2")
setwd("~/Documents/RUG/Thesis/EMA-mindfulness/Data/ESM/mindcog_v202202-2")
library(readxl)
library(tidyverse)
library(plyr)
library(dplyr)
library(Hmisc)
library(corrplot)
library(data.table)
library(ggplot2)
library(reshape)
library(ggpubr)
library(lubridate)
library(igraph)
library(qgraph)
#read in data
data <- read_xlsx('mindcog_db_2022-02-14.xlsx')
################################# add id, intervention #################################################
#get sheet names
#sheetnames <- excel_sheets('Medoq_informatie_2.xlsx')
mylist <- lapply(excel_sheets('Medoq_informatie_2.xlsx'), read_excel, path = 'Medoq_informatie_2.xlsx')
# name the dataframes
names(mylist) <- c("matchingMindfulness", "matchingFantasizing")
# Bring the dataframes to the global environment
list2env(mylist ,.GlobalEnv)
matchingMindfulness$intervention <- "mindfulness" #add intervention type per sheet
matchingFantasizing$intervention <- "fantasizing"
matchingData <- rbind(matchingMindfulness, matchingFantasizing) #bind into one df
#changing column names of Datum Baseline and Datum Interventie since spaces lead to weird errors
colnames(matchingData)[c(1,4,5,6)] <- c("id", "meeting_id", "DatesBaseline", "DatesIntervention")
#extract start and end dates from "Datum baseline" and "Datum interventie" columns
for(row in 1:nrow(matchingData)) { #change all "t/m" to "tm"
if( ! (grepl("tm", matchingData$DatesBaseline[row], fixed=TRUE))){
matchingData$DatesBaseline[row] <- sub("t/m", "\\tm", matchingData$DatesBaseline[row])
}
if( ! (grepl("tm", matchingData$DatesIntervention[row], fixed=TRUE))){
matchingData$DatesIntervention[row] <- sub("t/m", "\\tm", matchingData$DatesIntervention[row])
}
}
matchingData$baselineStart <- NA
matchingData$baselineEnd <- NA
matchingData$interventionStart <- NA
matchingData$interventionEnd <- NA
for(row in 1:nrow(matchingData)){
if(! is.na(matchingData$DatesBaseline[row])){
matchingData$baselineStart[row] <- sub("\\ tm.*", "", matchingData$DatesBaseline[row]) #extract start date
matchingData$baselineEnd[row] <- sub(".* tm", "", matchingData$DatesBaseline[row]) #extract end date
#same for intervention dates
matchingData$interventionStart[row] <- sub("\\ tm.*", "", matchingData$DatesIntervention[row])
matchingData$interventionEnd[row] <- sub(".* tm", "", matchingData$DatesIntervention[row])
}
}
#performing a "vlookup" of the md... numbers and adding corresponding columns
#from matchingData to data
data$id <- NA
data$intervention <- NA
data$baselineDates <- NA
data$interventionDates <- NA
for(i in 1:nrow(data)){
for(j in 1:nrow(matchingData)){
if(data$patient_id[i] == matchingData$meeting_id[j]){
data$id[i] <- matchingData$id[j]
data$intervention[i] <- matchingData$intervention[j]
data$baselineDates[i] = matchingData$DatesBaseline[j]
data$interventionDates[i] <- matchingData$DatesIntervention[j]
}
}
}
#################################### Data clean up ####################################
#turn all ids to lower case for easier error handling below
data$id <- tolower(data$id)
#fix various errors in id column
for(row in 1:nrow(data)) { #some "s" are missing
if( ! (grepl("s", data$id[row], fixed=TRUE)) & (!(is.na(data$id[row])))){
data$id[row] <- paste("s", data$id[row], sep = "")
}
if( ! (grepl("_g", data$id[row], fixed=TRUE))){ #some "_" prior to "g" are missing
data$id[row] <- sub("g", "\\1_g", data$id[row])
}
if( ! (grepl("_m", data$id[row], fixed = TRUE))){ #some "_" prior to "m" are missing
data$id[row] <- sub("m", "\\1_m", data$id[row])
}
if( (grepl("meting", data$id[row], fixed = TRUE))){#some had "meting" instead of just "m"
data$id[row] <- sub("meting", "\\1m", data$id[row])
}
}
#add group
data$group <- NA
for(row in 1:nrow(data)) {
if(grepl("g1", data$id[row], fixed = TRUE)){
data$group[row] <- "controls"
}
if(grepl("g2", data$id[row], fixed = TRUE)){
data$group[row] <- "remitted"
}
}
missing_data <- ddply(data, .(patient_id, id, group, intervention), plyr::summarise,
numBeeped = length(mindcog_db_open_from),
responseRate = round((numBeeped - length(unique(mindcog_db_non_response)))/numBeeped,2))
na_data <- missing_data[(is.na(missing_data$patient_id)) |
is.na((missing_data$group)) |
is.na((missing_data$intervention)), ]
#write.csv(na_data, file = "patientID_issues.csv")
#convert excel na to R na and remove respondents without group (for now)
#data[data=="#N/A"] = NA
#drop subjects without an assigned group
data <- drop_na(data, group)
data <- drop_na(data, patient_id)
################################# add phase, block, subject ########################################################
data$phase <- NA
for(row in 1:nrow(data)) {
if((grepl("m1", data$id[row], fixed = TRUE)) | (grepl("m3", data$id[row], fixed = TRUE))){
data$phase[row] <- "pre"
}
if((grepl("m2", data$id[row], fixed = TRUE)) | (grepl("m4", data$id[row], fixed = TRUE))){
data$phase[row] <- "peri"
}
}
#add block (1 = first intervention cycle, 2 = second intervention cycle)
data$block <- NA
for(row in 1:nrow(data)) {
if((grepl("m1", data$id[row], fixed = TRUE)) | (grepl("m2", data$id[row], fixed = TRUE))){
data$block[row] <- 1
} else {
data$block[row] <- 2
}
}
#test <- subset(data, select = c(id, phase, block))
#add new column "subject" -> extract all characters up until the first underscore in column "id"
data$subject <- str_extract(data$id, regex("^[^_]+(?=_)"))
#Changing ESM item names
#Get numbers of ESM item columns
item1 <- which( colnames(data)=="mindcog_db_1" ) #this is the first column that interests us
item33 <- which( colnames(data)=="mindcog_db_33" )#last item of interest
colNamesOld <- setNames(data.frame(colnames(data[, item1:item33])), "columns")
colNamesNew <- c('firstEntry', 'sleepQuality', 'toBedHour', 'toBedMinute', 'trySleepHour', 'trySleepMinute',
'durationFallAsleep', 'wakeupHour', 'wakeupMinute', 'restednessWakeup', 'wakeful',
'sad', 'satisfied', 'irritated', 'energetic', 'restless', 'stressed', 'anxious',
'listless', 'thinkingOf', 'worried', 'stickiness', 'thoughtsPleasant',
'thoughtsTime', 'thoughtsValence', 'thoughtsObject', 'distracted',
'restOfDayPos', 'aloneCompany', 'companyPleasant', 'alonePleasant', 'posMax',
'posIntensity', 'negMax', 'negIntensity', 'comments')
setnames(data, old = colNamesOld$columns, new = colNamesNew)
#################################### add measures on response times  ####################################
#Convert dates from characters to datetimes
data[['mindcog_db_open_from']] <- as.POSIXct(data[['mindcog_db_open_from']],
format = "%d/%m/%Y %H:%M")
data[['mindcog_db_started_at']] <- as.POSIXct(data[['mindcog_db_started_at']],
format = "%d/%m/%Y %H:%M")
data[['mindcog_db_completed_at']] <- as.POSIXct(data[['mindcog_db_completed_at']],
format = "%d/%m/%Y %H:%M")
#calculate the time it took a participant to start after being informed (in minutes)
data$response_delay <- (data$mindcog_db_started_at - data$mindcog_db_open_from)/60
#calculate how long it took a participant to complete the questionnaire (in minutes)
data$response_duration <- (data$mindcog_db_completed_at - data$mindcog_db_started_at)/60
#calculate the minutes that have past since the last beep
subject_IDs <- unique(data$subject) #get a list of all unique IDs
data$minLastBeep <- NA
for(id in subject_IDs){ #for loop to fill the column with the day numbers
prev_row = 0
xDate <- as.Date("01/01/1999", format = '%d/%m/%Y') #low arbitrary date for comparison of first assessment date
respondent_rows <- which(data$subject == id) #row indices of rows associated with respondent
for (row in respondent_rows) { #loop over these rows
#if this rows date is greater than the previous assessment's date
if(as.Date(data$mindcog_db_open_from[row]) == as.Date(xDate)){
timePast = hms(as.ITime(data$mindcog_db_open_from[row]) - as.ITime(data$mindcog_db_open_from[prev_row]))
minutesPast = hour(timePast)*60 + minute(timePast) #increment the assessment day count
data$minLastBeep[row] <- minutesPast #add the minutes past
prev_row = row #update the previous row index (not plus one bc numbers are not continuous!)
xDate = data$mindcog_db_open_from[row] #set new comparison date to date of current row
} else {
#otherwise this row's date is equal to the previous row's --> same assessment day
data$minLastBeep[row] <- NA
prev_row = row
xDate = data$mindcog_db_open_from[row] #set new comparison date to date of current row
}
}
}
#test <- subset(data, select = c(id, subject, mindcog_db_open_from, minLastBeep))
#group by respondent_id and count the number on nonresponses
participant_responses <- ddply(data, .(subject), plyr::summarise,
numBeeped = length(mindcog_db_open_from),
noResponse = length(unique(mindcog_db_non_response)),
response = numBeeped - noResponse,
responseRate = round(response/numBeeped,2))
#the mean response rate is ~65%
meanResponseRate <- mean(participant_responses$responseRate)
#sd of 23.46
sdResponseRate <- sd(participant_responses$responseRate)
#################################### Beep number, assessment day and lagged variables  ####################################
#adding beep number (continuous count of sent assessment queries)
data$beepNum <- NA
for(id in subject_IDs){ #every participant
respondent_rows <- which(data$subject == id) #row indices of rows associated with respondent
#adding a number per assessment
data[respondent_rows,]$beepNum <- 1:length(respondent_rows)
}
#beep number per phase
data$phaseBeepNum <- NA
phases <- unique(data$phase)
for(id in subject_IDs){ #every participant
for(phase in phases){
phase_rows <- which((data$subject == id) & (data$phase == phase)) #row indices of rows associated with respondent
if(length(phase_rows) > 0){
data[phase_rows,]$phaseBeepNum <- 1:length(phase_rows)
}
}
}
#beep number per block
data$blockBeepNum <- NA
for(id in subject_IDs){ #every participant
for(block in 1:2){
block_rows <- which((data$subject == id) & (data$block == block)) #row indices of rows associated with respondent
if(length(block_rows) > 0){
data[block_rows,]$blockBeepNum <- 1:length(block_rows)
}
}
}
#test <- subset(data[data$subject == "s8",], select = c(subject, phase, block, blockBeepNum, phaseBeepNum, beepNum))
#adding assessment day
data$assessmentDay <- NA #adding an empty column for assessment days
for(id in subject_IDs){ #for loop to fill the column with the day numbers
assessment_day <- 0
prev_row = 0
xDate <- as.Date("01/01/1999", format = '%d/%m/%Y') #low arbitrary date for comparison of first assessment date
respondent_rows <- which(data$subject == id) #row indices of rows associated with respondent
for (row in respondent_rows) { #loop over these rows
#if this rows date is greater than the previous assessment's date
if(as.Date(data$mindcog_db_open_from[row]) > xDate){
assessment_day = assessment_day + 1 #increment the assessment day count
data$assessmentDay[row] <- assessment_day #and add this new number as assessment day for this row
prev_row = row #update the previous row index (not plus one bc numbers are not continuous!)
xDate = as.Date(data$mindcog_db_open_from[row]) #set new comparison date to date of current row
} else {
#otherwise this row's date is equal to the previous row's --> same assessment day
data$assessmentDay[row] <- data$assessmentDay[prev_row]
prev_row = row
}
}
}
phases <- c("pre", "peri")
data$phaseAssessmentDay <- NA
for(id in subject_IDs){
for(p in phases){
for(block in 1:2){
assessment_day <- 0
prev_row = 0
xDate <- as.Date("01/01/1999", format = '%d/%m/%Y')
phase_rows <- which((data$subject == id) & (data$block == block) & (data$phase == p))
if(length(phase_rows) > 0){
for (row in phase_rows) { #loop over these rows
#if this rows date is greater than the previous assessment's date
if(as.Date(data$mindcog_db_open_from[row]) > xDate){
assessment_day = assessment_day + 1 #increment the assessment day count
data$phaseAssessmentDay[row] <- assessment_day #and add this new number as assessment day for this row
prev_row = row #update the previous row index (not plus one bc numbers are not continuous!)
xDate = as.Date(data$mindcog_db_open_from[row]) #set new comparison date to date of current row
} else {
#otherwise this row's date is equal to the previous row's --> same assessment day
data$phaseAssessmentDay[row] <- data$phaseAssessmentDay[prev_row]
prev_row = row
}
}
}
}
}
}
# View(subset(data[which(data$subject == "s8"),],
#     select = c("patient_id", "id", "intervention", "phase", "mindcog_db_open_from",
#           "assessmentDay", "blockAssessmentDay", "phaseAssessmentDay")))
#test <- subset(data, select = c(id, subject, mindcog_db_open_from, assessmentDay))
#assessment day per block
data$blockAssessmentDay <- NA #adding an empty column for assessment days
for(id in subject_IDs){ #for loop to fill the column with the day numbers
for(block in 1:2){
assessment_day <- 0
prev_row = 0
xDate <- as.Date("01/01/1999", format = '%d/%m/%Y') #low arbitrary date for comparison of first assessment date
block_rows <- which((data$subject == id) & (data$block == block)) #row indices of rows associated with respondent
if(length(block_rows) > 0){
for (row in block_rows) { #loop over these rows
#if this rows date is greater than the previous assessment's date
if(as.Date(data$mindcog_db_open_from[row]) > xDate){
assessment_day = assessment_day + 1 #increment the assessment day count
data$blockAssessmentDay[row] <- assessment_day #and add this new number as assessment day for this row
prev_row = row #update the previous row index (not plus one bc numbers are not continuous!)
xDate = as.Date(data$mindcog_db_open_from[row]) #set new comparison date to date of current row
} else {
#otherwise this row's date is equal to the previous row's --> same assessment day
data$blockAssessmentDay[row] <- data$blockAssessmentDay[prev_row]
prev_row = row
}
}
}
}
}
#drop unnecessary columns and reorder columns for convenience
columnNames <- c(colnames(data))
data <- data %>% select(patient_id, id, subject, group, intervention, phase, block,
#18 = db_open_from; 23 = db_date; 26:61 = firstEntry:comments; 67:76
columnNames[18:23], baselineDates, interventionDates, columnNames[26:61],
#67:78 = response measures
columnNames[70:78])
# data <- subset(data, select = -c(roqua_id, hide_pii_from_researchers, gender, birth_year,
#                                  hide_values_from_professionals, respondent_label, respondent_type,
#                                  mindcog_db_project, mindcog_db_notes, mindcog_db_location,
#                                  mindcog_db_invited_at, mindcog_db_emailed_at, mindcog_db_variant,
#                                  mindcog_db_anonymous, mindcog_db_protocol, mindcog_db_measurement))
View(matchingData)

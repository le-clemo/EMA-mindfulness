data <- drop_na(data, patient_id)
#View(data[which(is.na(data$mindcog_db_date)),])
############################# Handle issue with diverging dates ###########################
#fix problem with dates (whether entry belongs to pre- or peri-intervention phase)
error_demo <- ddply(data[which(data$subject=="s3"),],
.(subject, id, phase, block, mindcog_db_date, recordedStart, recordedEnd,
baselineStart, baselineEnd, interventionStart, interventionEnd), plyr::summarise,
nEntries <- length(subject))
#turning the recordedStart/-End, baselineStart/-End, ... into actual dates with corresponding year
for(row in 1:nrow(data)){ #first extract year from the mindcog_db_date column
y <- format(as.POSIXct(data$mindcog_db_date[row], format = "%Y-%m-%d"), format="%Y")
#if there is an entry for recordedStart and mindcog_db_date (i.e., if its not a non-response)
if((!is.na(data$recordedStart[row])) & (!is.na(data$mindcog_db_date[row]))){
#combine day-month from recordedStart (etc.) with extracted year and reformat to match other dates in df
data$recordedStart[row] <- format(as.POSIXct(paste(data$recordedStart[row], y, sep = "-"),
format = "%d-%m-%Y"), format = "%Y-%m-%d")
data$recordedEnd[row] <- format(as.POSIXct(paste(data$recordedEnd[row], y, sep = "-"),
format = "%d-%m-%Y"), format = "%Y-%m-%d")
}# repeat for other columns
if((!is.na(data$baselineStart[row])) & (!is.na(data$mindcog_db_date[row]))){
data$baselineStart[row] <- format(as.POSIXct(paste(data$baselineStart[row], y, sep = "-"),
format = "%d-%m-%Y"), format = "%Y-%m-%d")
data$baselineEnd[row] <- format(as.POSIXct(paste(data$baselineEnd[row], y, sep = "-"),
format = "%d-%m-%Y"), format = "%Y-%m-%d")
data$interventionStart[row] <- format(as.POSIXct(paste(data$interventionStart[row], y, sep = "-"),
format = "%d-%m-%Y"), format = "%Y-%m-%d")
data$interventionEnd[row] <- format(as.POSIXct(paste(data$interventionEnd[row], y, sep = "-"),
format = "%d-%m-%Y"), format = "%Y-%m-%d")
}
}
pre_to_peri <- c() #empty lists for row indices of faulty entries
peri_to_pre <- c()
i <- 1 #to add to the lists (in a computationally efficient way)
j <- 1
for(row in 1:nrow(data)){
#if there is a date in baselineStart (which means there is one in the other relevant columns too)
# and if it is not a non-response
if((!is.na(data$baselineStart[row])) & (!is.na(data$mindcog_db_date[row]))){
#if phase is "pre"
if((!is.na(data$phase[row])) & (data$phase[row] == "pre")){
#if the recorded mindcog date is greater than the end of baseline date
if((data$mindcog_db_date[row] > data$baselineEnd[row])){
pre_to_peri[i] <- row #add row index to list
i <- i+1 #increment list index count
}
} #same for entries coded as peri that should be pre
if((!is.na(data$phase[row])) & (data$phase[row] == "peri")){
if((data$mindcog_db_date[row] < data$interventionStart[row])){
peri_to_pre[j] <- row
j <- j+1
}
}
}
}
data[pre_to_peri,]$phase <- "peri"
for(row in pre_to_peri){
if((grepl("m1", data$id[row], fixed=TRUE))){
data$id[row] <- sub("m1", "\\m2", data$id[row])
}
if((grepl("m3", data$id[row], fixed=TRUE))){
data$id[row] <- sub("m3", "\\m4", data$id[row])
}
}
data[peri_to_pre,]$phase <- "pre"
for(row in peri_to_pre){
if((grepl("m2", data$id[row], fixed=TRUE))){
data$id[row] <- sub("m2", "\\m1", data$id[row])
}
if((grepl("m4", data$id[row], fixed=TRUE))){
data$id[row] <- sub("m4", "\\m3", data$id[row])
}
}
# View(data[pre_to_peri,])
# View(data[peri_to_pre,])
# length(pre_to_peri)
# length(peri_to_pre)
# pre_to_peri_df <- (subset(data[pre_to_peri,], select=c("id", "mindcog_db_date", "phase", "baselineStart",
#                                     "baselineEnd", "interventionStart", "interventionEnd")))
#
# peri_to_pre_df <- (subset(data[peri_to_pre,], select=c("id", "mindcog_db_date", "phase", "baselineStart",
#                                                        "baselineEnd", "interventionStart", "interventionEnd")))
######################################## Changing ESM item names ##############################
#Get numbers of ESM item columns
item1 <- which( colnames(data)=="mindcog_db_1" ) #this is the first column that interests us
item33 <- which( colnames(data)=="mindcog_db_33" )#last item of interest
colNamesOld <- setNames(data.frame(colnames(data[, item1:item33])), "columns")
colNamesNew <- c('firstEntry', 'sleepQuality', 'toBedHour', 'toBedMinute', 'trySleepHour', 'trySleepMinute',
'durationFallAsleep', 'wakeupHour', 'wakeupMinute', 'restednessWakeup', 'wakeful',
'sad', 'satisfied', 'irritated', 'energetic', 'restless', 'stressed', 'anxious',
'listless', 'thinkingOf', 'worried', 'stickiness', 'thoughtsPleasant',
'thoughtsTime', 'thoughtsValence', 'thoughtsObject', 'distracted',
'restOfDayPos', 'aloneCompany', 'companyPleasant', 'alonePleasant', 'posMax',
'posIntensity', 'negMax', 'negIntensity', 'comments')
setnames(data, old = colNamesOld$columns, new = colNamesNew)
#################################### add measures on response times  ####################################
#calculate the time it took a participant to start after being informed (in minutes)
data$response_delay <- (data$mindcog_db_started_at - data$mindcog_db_open_from)/60
#calculate how long it took a participant to complete the questionnaire (in minutes)
data$response_duration <- (data$mindcog_db_completed_at - data$mindcog_db_started_at)/60
#calculate the minutes that have past since the last beep
subject_IDs <- unique(data$subject) #get a list of all unique IDs
data$minLastBeep <- NA
for(id in subject_IDs){ #for loop to fill the column with the day numbers
prev_row = 0
xDate <- as.Date("01/01/1999", format = '%d/%m/%Y') #low arbitrary date for comparison of first assessment date
respondent_rows <- which(data$subject == id) #row indices of rows associated with respondent
for (row in respondent_rows) { #loop over these rows
#if this rows date is greater than the previous assessment's date
if(as.Date(data$mindcog_db_open_from[row]) == as.Date(xDate)){
timePast = hms(as.ITime(data$mindcog_db_open_from[row]) - as.ITime(data$mindcog_db_open_from[prev_row]))
minutesPast = hour(timePast)*60 + minute(timePast) #increment the assessment day count
data$minLastBeep[row] <- minutesPast #add the minutes past
prev_row = row #update the previous row index (not plus one bc numbers are not continuous!)
xDate = data$mindcog_db_open_from[row] #set new comparison date to date of current row
} else {
#otherwise this row's date is equal to the previous row's --> same assessment day
data$minLastBeep[row] <- NA
prev_row = row
xDate = data$mindcog_db_open_from[row] #set new comparison date to date of current row
}
}
}
#test <- subset(data, select = c(id, subject, mindcog_db_open_from, minLastBeep))
####################### Beep number, assessment day and lagged variables  #############################
#adding beep number (continuous count of sent assessment queries)
data$beepNum <- NA
for(id in subject_IDs){ #every participant
respondent_rows <- which(data$subject == id) #row indices of rows associated with respondent
#adding a number per assessment
data[respondent_rows,]$beepNum <- 1:length(respondent_rows)
}
#beep number per phase
data$phaseBeepNum <- NA
phases <- unique(data$phase)
for(id in subject_IDs){ #every participant
for(phase in phases){
phase_rows <- which((data$subject == id) & (data$phase == phase)) #row indices of rows associated with respondent
if(length(phase_rows) > 0){
data[phase_rows,]$phaseBeepNum <- 1:length(phase_rows)
}
}
}
#beep number per block
data$blockBeepNum <- NA
for(id in subject_IDs){ #every participant
for(block in 1:2){
block_rows <- which((data$subject == id) & (data$block == block)) #row indices of rows associated with respondent
if(length(block_rows) > 0){
data[block_rows,]$blockBeepNum <- 1:length(block_rows)
}
}
}
#test <- subset(data[data$subject == "s8",], select = c(subject, phase, block, blockBeepNum, phaseBeepNum, beepNum))
#adding assessment day
data$assessmentDay <- NA #adding an empty column for assessment days
for(id in subject_IDs){ #for loop to fill the column with the day numbers
assessment_day <- 0
prev_row = 0
xDate <- as.Date("01/01/1999", format = '%d/%m/%Y') #low arbitrary date for comparison of first assessment date
respondent_rows <- which(data$subject == id) #row indices of rows associated with respondent
for (row in respondent_rows) { #loop over these rows
#if this rows date is greater than the previous assessment's date
if(as.Date(data$mindcog_db_open_from[row]) > xDate){
assessment_day = assessment_day + 1 #increment the assessment day count
data$assessmentDay[row] <- assessment_day #and add this new number as assessment day for this row
prev_row = row #update the previous row index (not plus one bc numbers are not continuous!)
xDate = as.Date(data$mindcog_db_open_from[row]) #set new comparison date to date of current row
} else {
#otherwise this row's date is equal to the previous row's --> same assessment day
data$assessmentDay[row] <- data$assessmentDay[prev_row]
prev_row = row
}
}
}
phases <- c("pre", "peri")
data$phaseAssessmentDay <- NA
for(id in subject_IDs){
for(p in phases){
for(block in 1:2){
assessment_day <- 0
prev_row = 0
xDate <- as.Date("01/01/1999", format = '%d/%m/%Y')
phase_rows <- which((data$subject == id) & (data$block == block) & (data$phase == p))
if(length(phase_rows) > 0){
for (row in phase_rows) { #loop over these rows
#if this rows date is greater than the previous assessment's date
if(as.Date(data$mindcog_db_open_from[row]) > xDate){
assessment_day = assessment_day + 1 #increment the assessment day count
data$phaseAssessmentDay[row] <- assessment_day #and add this new number as assessment day for this row
prev_row = row #update the previous row index (not plus one bc numbers are not continuous!)
xDate = as.Date(data$mindcog_db_open_from[row]) #set new comparison date to date of current row
} else {
#otherwise this row's date is equal to the previous row's --> same assessment day
data$phaseAssessmentDay[row] <- data$phaseAssessmentDay[prev_row]
prev_row = row
}
}
}
}
}
}
# View(subset(data[which(data$subject == "s8"),],
#     select = c("patient_id", "id", "intervention", "phase", "mindcog_db_open_from",
#           "assessmentDay", "blockAssessmentDay", "phaseAssessmentDay")))
#test <- subset(data, select = c(id, subject, mindcog_db_open_from, assessmentDay))
#assessment day per block
data$blockAssessmentDay <- NA #adding an empty column for assessment days
for(id in subject_IDs){ #for loop to fill the column with the day numbers
for(block in 1:2){
assessment_day <- 0
prev_row = 0
xDate <- as.Date("01/01/1999", format = '%d/%m/%Y') #low arbitrary date for comparison of first assessment date
block_rows <- which((data$subject == id) & (data$block == block)) #row indices of rows associated with respondent
if(length(block_rows) > 0){
for (row in block_rows) { #loop over these rows
#if this rows date is greater than the previous assessment's date
if(as.Date(data$mindcog_db_open_from[row]) > xDate){
assessment_day = assessment_day + 1 #increment the assessment day count
data$blockAssessmentDay[row] <- assessment_day #and add this new number as assessment day for this row
prev_row = row #update the previous row index (not plus one bc numbers are not continuous!)
xDate = as.Date(data$mindcog_db_open_from[row]) #set new comparison date to date of current row
} else {
#otherwise this row's date is equal to the previous row's --> same assessment day
data$blockAssessmentDay[row] <- data$blockAssessmentDay[prev_row]
prev_row = row
}
}
}
}
}
############################## Some changes for convenience ################################
#drop unnecessary columns and reorder columns for convenience
columnNames <- c(colnames(data))
data <- data %>% select(patient_id, id, subject, group, intervention, phase, block,
#18 = db_open_from; 23 = db_date; 26:61 = firstEntry:comments; 67:76
columnNames[18:23], columnNames[26:61],
#67:78 = response measures
columnNames[74:82])
# data <- subset(data, select = -c(roqua_id, hide_pii_from_researchers, gender, birth_year,
#                                  hide_values_from_professionals, respondent_label, respondent_type,
#                                  mindcog_db_project, mindcog_db_notes, mindcog_db_location,
#                                  mindcog_db_invited_at, mindcog_db_emailed_at, mindcog_db_variant,
#                                  mindcog_db_anonymous, mindcog_db_protocol, mindcog_db_measurement))
###################################### Creating lagged variables #############################################
#the variables to be lagged
cols <- c('wakeful', 'sad', 'satisfied', 'irritated', 'energetic', 'restless', 'stressed', 'anxious',
'listless', 'thinkingOf', 'worried', 'stickiness', 'thoughtsPleasant', 'thoughtsTime',
'thoughtsValence', 'thoughtsObject', 'distracted', 'restOfDayPos', 'aloneCompany',
'companyPleasant', 'alonePleasant', 'posMax', 'posIntensity', 'negMax', 'negIntensity')
#creating a vector with new "lagged" column names
laggedCols <- c()
for(col in cols) {
laggedCols <- c(laggedCols, paste(col, "lag1", sep = "_"))
}
#adding empty columns with "lagged" names
data[, laggedCols] <- NA
#zipping current and lagged column names for the for loop
colZip <- mapply(c, cols, laggedCols, SIMPLIFY = FALSE)
#for loop to add the lagged values to their corresponding new columns
for(id in subject_IDs){
respondent_rows <- which(data$subject == id) #one respondent at a time
for(col in colZip) { #looping over the zipped column name pairs
prev_value <- NA #previous value starts out as NA for every column
current_day <- 1 #current day at the beginning of every column per respondent is 1
for(row in respondent_rows) { #looping over the rows associated with the current respondent
if(data$assessmentDay[row] == current_day) { #if the assessment day matches the current day
data[row, col[2]] <- prev_value #add the previous value as the value for the lagged column
prev_value <- data[row, col[1]] #update the previous value
} else { #if assessment day and current day do not match
data[row, col[2]] <- NA #then the lagged value should be NA (new day!)
current_day <- data$assessmentDay[row] #update the current day (could also just be +1)
prev_value <- data[row, col[1]] #update previous value
}
}
}
}
############################################ Change scores ####################################################
cols <- c('wakeful', 'sad', 'satisfied', 'irritated', 'energetic', 'restless', 'stressed', 'anxious',
'listless', 'worried', 'stickiness', 'thoughtsPleasant',  'thoughtsObject', 'distracted', 'restOfDayPos',
'companyPleasant', 'alonePleasant', 'posMax', 'posIntensity', 'negMax', 'negIntensity')
#creating a vector with new "lagged" column names
changeCols <- c()
for(col in cols) {
changeCols <- c(changeCols, paste(col, "change", sep = "_"))
}
#adding empty columns with "lagged" names
data[, changeCols] <- NA
#zipping current and lagged column names for the for loop
colZip <- mapply(c, cols, changeCols, SIMPLIFY = FALSE)
#for loop to add the lagged values to their corresponding new columns
for(id in subject_IDs){
respondent_rows <- which(data$subject == id) #one respondent at a time
for(col in colZip) { #looping over the zipped column name pairs
prev_value <- 0
change_score <- NA #previous value starts out as NA for every column
current_day <- 1 #current day at the beginning of every column per respondent is 1
for(row in respondent_rows) { #looping over the rows associated with the current respondent
if(data$assessmentDay[row] == current_day) { #if the assessment day matches the current day
change_score <- data[row, col[1]] - prev_value #calculate next change score
data[row, col[2]] <- change_score #add the change_score as the value for the lagged column
prev_value <- data[row, col[1]] #update the previous value
} else { #if assessment day and current day do not match
data[row, col[2]] <- NA #then the change score should be NA (new day!)
current_day <- data$assessmentDay[row] #update the current day (could also just be +1)
prev_value <- data[row, col[1]] #update previous value
}
}
}
}
# test <- subset(data, select = c(subject, phase, sad, sad_change, assessmentDay))
# View(test)
write.csv(data, "preprocessed_data.csv", row.names = FALSE)
#################################### Set up ####################################
rm(list = ls()) #clean all up
setwd("C:/Users/cleme/Documents/Education/RUG/Thesis/EMA-mindfulness/Data/ESM/mindcog_v202204")
library(readxl)
library(tidyverse)
library(plyr)
library(dplyr)
library(Hmisc)
library(corrplot)
library(data.table)
library(ggplot2)
library(reshape)
library(ggpubr)
library(lubridate)
library(igraph)
#read in data
data <- read.csv('preprocessed_data.csv')
View(data)
#recreacting with assessment days per participant
participant_responses <- ddply(data, .(subject), plyr::summarise,
numBeeped = length(mindcog_db_open_from),
noResponse = length(unique(mindcog_db_non_response)),
response = numBeeped - noResponse,
responseRate = round(response/numBeeped,2),
numDays = max(assessmentDay))
#recreacting with assessment days per group
group_responses <- ddply(data, .(group), plyr::summarise,
nSubj = length(unique(subject)),
numBeeped = length(mindcog_db_open_from),
noResponse = length(unique(mindcog_db_non_response)),
response = numBeeped - noResponse,
responseRate = round(response/numBeeped,2),
numDays = max(assessmentDay)) #6% higher response rate in controls
View(group_responses)
View(participant_responses)
#the mean response rate is ~66%
meanResponseRate <- mean(participant_responses$responseRate)
#sd of 20.48
sdResponseRate <- sd(participant_responses$responseRate)
#number of respondents (i.e., participants?) so far
length(unique(data$subject)) #35 associated with a group
#calculating statistics per group (remitted vs controls)
grp_avgs <- ddply(data, .(group), plyr::summarize,
n_Subj = length(unique(subject)),
db2_sleep_avg = mean(sleepQuality, na.rm = TRUE),
db2_sleep_sd = sd(sleepQuality, na.rm = TRUE),
db8_wakeful_avg = mean(wakeful, na.rm = TRUE),
db9_sad_avg = mean(sad, na.rm = TRUE),
db9_sad_sd = sd(sad, na.rm = TRUE),
db10_satisfied_avg = mean(satisfied, na.rm = TRUE),
db10_satisfied_sd = sd(satisfied, na.rm = TRUE),
db11_irritated_avg = mean(irritated, na.rm = TRUE),
db12_energetic_avg = mean(energetic, na.rm = TRUE),
db13_restless_avg = mean(restless, na.rm = TRUE),
db14_stressed_avg = mean(stressed, na.rm = TRUE),
db15_anxious_avg = mean(anxious, na.rm = TRUE),
db16_listless_avg = mean(listless, na.rm = TRUE),
db18_worrying_avg = mean(worried, na.rm = TRUE),
db19_stickiness_avg = mean(stickiness, na.rm = TRUE),
db20_easeThoughts_avg = mean(thoughtsPleasant, na.rm = TRUE),
db24_distracted_avg = mean(distracted, na.rm = TRUE),
db25_restOfDayPos_avg = mean(restOfDayPos, na.rm = TRUE),
db27_companyPos_avg = mean(companyPleasant, na.rm = TRUE),
db28_solitudePos_avg = mean(alonePleasant, na.rm = TRUE),
db29_enjoyabilityMax_avg = mean(posMax, na.rm = TRUE),
db30_intensityPos_avg = mean(posIntensity, na.rm = TRUE),
db31_unpleasantMax_avg = mean(negMax, na.rm = TRUE),
db32_intensityNeg_avg = mean(negIntensity, na.rm = TRUE),
response_delay_avg = round(mean(response_delay, na.rm = TRUE), 2),
response_duration_avg = round(mean(response_duration, na.rm = TRUE), 2))
View(group_responses)
View(grp_avgs)
#Metric columns
metricCols <- c('wakeful', 'sad', 'satisfied', 'irritated', 'energetic', 'restless',
'stressed', 'anxious', 'listless', 'worried', 'stickiness', 'thoughtsPleasant', 'distracted',
'restOfDayPos', 'posMax', 'posIntensity', 'negMax', 'negIntensity')
#for some strange dplyr-ralted reason I need to do this to get melt() to work
data <- as.data.frame(data)
#boxplot comparisons
meltData1 <- melt(data[, c("group", metricCols[1:9])])
p1 <- ggplot(meltData1, aes(factor(variable), value, fill = group))
p1 + geom_boxplot() + facet_wrap(~variable, scale="free")
meltData2 <- melt(data[, c("group", metricCols[10:18])])
p2 <- ggplot(meltData2, aes(factor(variable), value, fill = group))
p2 + geom_boxplot() + facet_wrap(~variable, scale="free")
#per group and intervention
int_avgs <- ddply(data, .(group, intervention), plyr::summarize,
n_Subj = length(unique(id)),
db2_sleep_avg = mean(sleepQuality, na.rm = TRUE),
db2_sleep_sd = sd(sleepQuality, na.rm = TRUE),
db8_wakeful_avg = mean(wakeful, na.rm = TRUE),
db9_sad_avg = mean(sad, na.rm = TRUE),
db9_sad_sd = sd(sad, na.rm = TRUE),
db10_satisfied_avg = mean(satisfied, na.rm = TRUE),
db10_satisfied_sd = sd(satisfied, na.rm = TRUE),
db11_irritated_avg = mean(irritated, na.rm = TRUE),
db12_energetic_avg = mean(energetic, na.rm = TRUE),
db13_restless_avg = mean(restless, na.rm = TRUE),
db14_stressed_avg = mean(stressed, na.rm = TRUE),
db15_anxious_avg = mean(anxious, na.rm = TRUE),
db16_listless_avg = mean(listless, na.rm = TRUE),
db18_worrying_avg = mean(worried, na.rm = TRUE),
db19_stickiness_avg = mean(stickiness, na.rm = TRUE),
db20_easeThoughts_avg = mean(thoughtsPleasant, na.rm = TRUE),
db24_distracted_avg = mean(distracted, na.rm = TRUE),
db25_restOfDayPos_avg = mean(restOfDayPos, na.rm = TRUE),
db27_companyPos_avg = mean(companyPleasant, na.rm = TRUE),
db28_solitudePos_avg = mean(alonePleasant, na.rm = TRUE),
db29_enjoyabilityMax_avg = mean(posMax, na.rm = TRUE),
db30_intensityPos_avg = mean(posIntensity, na.rm = TRUE),
db31_unpleasantMax_avg = mean(negMax, na.rm = TRUE),
db32_intensityNeg_avg = mean(negIntensity, na.rm = TRUE))
#boxplot comparisons
meltData1 <- melt(data[which(data$phase=="pre"), c("group", metricCols[1:9])])
p1 <- ggplot(meltData1, aes(factor(variable), value, fill = group))
p1 + geom_boxplot() + facet_wrap(~variable, scale="free")
meltData2 <- melt(data[, c("group", metricCols[10:18])])
p2 <- ggplot(meltData2, aes(factor(variable), value, fill = group))
p2 + geom_boxplot() + facet_wrap(~variable, scale="free")
#per group and intervention
int_avgs <- ddply(data, .(group, intervention), plyr::summarize,
n_Subj = length(unique(id)),
db2_sleep_avg = mean(sleepQuality, na.rm = TRUE),
db2_sleep_sd = sd(sleepQuality, na.rm = TRUE),
db8_wakeful_avg = mean(wakeful, na.rm = TRUE),
db9_sad_avg = mean(sad, na.rm = TRUE),
db9_sad_sd = sd(sad, na.rm = TRUE),
db10_satisfied_avg = mean(satisfied, na.rm = TRUE),
db10_satisfied_sd = sd(satisfied, na.rm = TRUE),
db11_irritated_avg = mean(irritated, na.rm = TRUE),
db12_energetic_avg = mean(energetic, na.rm = TRUE),
db13_restless_avg = mean(restless, na.rm = TRUE),
db14_stressed_avg = mean(stressed, na.rm = TRUE),
db15_anxious_avg = mean(anxious, na.rm = TRUE),
db16_listless_avg = mean(listless, na.rm = TRUE),
db18_worrying_avg = mean(worried, na.rm = TRUE),
db19_stickiness_avg = mean(stickiness, na.rm = TRUE),
db20_easeThoughts_avg = mean(thoughtsPleasant, na.rm = TRUE),
db24_distracted_avg = mean(distracted, na.rm = TRUE),
db25_restOfDayPos_avg = mean(restOfDayPos, na.rm = TRUE),
db27_companyPos_avg = mean(companyPleasant, na.rm = TRUE),
db28_solitudePos_avg = mean(alonePleasant, na.rm = TRUE),
db29_enjoyabilityMax_avg = mean(posMax, na.rm = TRUE),
db30_intensityPos_avg = mean(posIntensity, na.rm = TRUE),
db31_unpleasantMax_avg = mean(negMax, na.rm = TRUE),
db32_intensityNeg_avg = mean(negIntensity, na.rm = TRUE))
#boxplot comparisons
meltData1 <- melt(data[which(data$phase=="pre"), c("group", metricCols[1:9])])
#boxplot(data=meltData, value~variable)
p1 <- ggplot(meltData1, aes(factor(variable), value, fill = group))
p1 + geom_boxplot() + facet_wrap(~variable, scale="free")
meltData2 <- melt(data[which(data$phase=="pre"), c("group", metricCols[10:18])])
#boxplot(data=meltData, value~variable)
p2 <- ggplot(meltData2, aes(factor(variable), value, fill = group))
p2 + geom_boxplot() + facet_wrap(~variable, scale="free")
#boxplot comparisons
meltData1 <- melt(data[which((data$phase=="pre") & (data$block==1)), c("group", metricCols[1:9])])
#for some strange dplyr-ralted reason I need to do this to get melt() to work
data <- as.data.frame(data)
#boxplot comparisons
meltData1 <- melt(data[which((data$phase=="pre") & (data$block==1)), c("group", metricCols[1:9])])
p1 <- ggplot(meltData1, aes(factor(variable), value, fill = group))
p1 + geom_boxplot() + facet_wrap(~variable, scale="free")
meltData2 <- melt(which((data$phase=="pre") & (data$block==1)), c("group", metricCols[10:18])])
p2 <- ggplot(meltData2, aes(factor(variable), value, fill = group))
p2 + geom_boxplot() + facet_wrap(~variable, scale="free")
#per group and intervention
int_avgs <- ddply(data, .(group, intervention), plyr::summarize,
n_Subj = length(unique(id)),
db2_sleep_avg = mean(sleepQuality, na.rm = TRUE),
db2_sleep_sd = sd(sleepQuality, na.rm = TRUE),
db8_wakeful_avg = mean(wakeful, na.rm = TRUE),
db9_sad_avg = mean(sad, na.rm = TRUE),
db9_sad_sd = sd(sad, na.rm = TRUE),
db10_satisfied_avg = mean(satisfied, na.rm = TRUE),
db10_satisfied_sd = sd(satisfied, na.rm = TRUE),
db11_irritated_avg = mean(irritated, na.rm = TRUE),
db12_energetic_avg = mean(energetic, na.rm = TRUE),
db13_restless_avg = mean(restless, na.rm = TRUE),
db14_stressed_avg = mean(stressed, na.rm = TRUE),
db15_anxious_avg = mean(anxious, na.rm = TRUE),
db16_listless_avg = mean(listless, na.rm = TRUE),
db18_worrying_avg = mean(worried, na.rm = TRUE),
db19_stickiness_avg = mean(stickiness, na.rm = TRUE),
db20_easeThoughts_avg = mean(thoughtsPleasant, na.rm = TRUE),
db24_distracted_avg = mean(distracted, na.rm = TRUE),
db25_restOfDayPos_avg = mean(restOfDayPos, na.rm = TRUE),
db27_companyPos_avg = mean(companyPleasant, na.rm = TRUE),
db28_solitudePos_avg = mean(alonePleasant, na.rm = TRUE),
db29_enjoyabilityMax_avg = mean(posMax, na.rm = TRUE),
db30_intensityPos_avg = mean(posIntensity, na.rm = TRUE),
db31_unpleasantMax_avg = mean(negMax, na.rm = TRUE),
db32_intensityNeg_avg = mean(negIntensity, na.rm = TRUE))
#boxplot comparisons
meltData1 <- melt(data[which((data$phase=="pre") & (data$block==1)), c("group", metricCols[1:9])])
p1 <- ggplot(meltData1, aes(factor(variable), value, fill = group))
p1 + geom_boxplot() + facet_wrap(~variable, scale="free")
meltData2 <- melt(data[which((data$phase=="pre") & (data$block==1)), c("group", metricCols[10:18])])
p2 <- ggplot(meltData2, aes(factor(variable), value, fill = group))
p2 + geom_boxplot() + facet_wrap(~variable, scale="free")

data$interventionEnd[row] <- format(as.POSIXct(paste(data$interventionEnd[row], y, sep = "-"),
format = "%d-%m-%Y"), format = "%Y-%m-%d")
}
}
pre_to_peri <- c() #empty lists for row indices of faulty entries
peri_to_pre <- c()
i <- 1 #to add to the lists (in a computationally efficient way)
j <- 1
for(row in 1:nrow(data)){
#if there is a date in baselineStart (which means there is one in the other relevant columns too)
# and if it is not a non-response
if((!is.na(data$baselineStart[row])) & (!is.na(data$mindcog_db_date[row]))){
#if phase is "pre"
if((!is.na(data$phase[row])) & (data$phase[row] == "pre")){
#if the recorded mindcog date is greater than the end of baseline date
if((data$mindcog_db_date[row] > data$baselineEnd[row])){
pre_to_peri[i] <- row #add row index to list
i <- i+1 #increment list index count
}
} #same for entries coded as peri that should be pre
if((!is.na(data$phase[row])) & (data$phase[row] == "peri")){
if((data$mindcog_db_date[row] < data$interventionStart[row])){
peri_to_pre[j] <- row
j <- j+1
}
}
}
}
length(pre_to_peri)
length(peri_to_pre)
View(error_demo)
data$phase[pre_to_peri,] <- "peri"
data[pre_to_peri,]$phase <- "peri"
for(row in 1:nrow(data[pre_to_peri,])){
if((grepl("m1", data$id[row], fixed=TRUE))){
data$id[row] <- sub("m1", "\\1m2", matchingData$id[row])
}
if((grepl("m3", data$id[row], fixed=TRUE))){
data$id[row] <- sub("m3", "\\1m4", matchingData$id[row])
}
}
############################# Handle issue with diverging dates ###########################
#fix problem with dates (whether entry belongs to pre- or peri-intervention phase)
error_demo <- ddply(data[which(data$subject=="s3"),],
.(subject, id, phase, block, mindcog_db_date, recordedStart, recordedEnd,
baselineStart, baselineEnd, interventionStart, interventionEnd), plyr::summarise,
nEntries <- length(subject))
View(data[pre_to_peri,])
data$id[1]
data[pre_to_peri,]$phase <- "peri"
for(row in 1:nrow(data[pre_to_peri,])){
if((grepl("m1", data$id[row], fixed=TRUE))){
data$id[row] <- sub("_m1", "\\1_m2", matchingData$id[row])
}
if((grepl("m3", data$id[row], fixed=TRUE))){
data$id[row] <- sub("_m3", "\\1_m4", matchingData$id[row])
}
}
View(data[pre_to_peri,])
data[pre_to_peri,]$phase <- "peri"
for(row in 1:nrow(data[pre_to_peri,])){
if((grepl("m1", data$id[row], fixed=TRUE))){
data$id[row] <- sub("_m1", "\\1_m2", data$id[row])
}
if((grepl("m3", data$id[row], fixed=TRUE))){
data$id[row] <- sub("_m3", "\\1_m4", data$id[row])
}
}
View(data[pre_to_peri,])
data[pre_to_peri,]$phase <- "peri"
for(row in 1:nrow(data[pre_to_peri,])){
if((grepl("m1", data$id[row], fixed=TRUE))){
data$id[row] <- sub("m1", "\\m2", data$id[row])
}
if((grepl("m3", data$id[row], fixed=TRUE))){
data$id[row] <- sub("m3", "\\m4", data$id[row])
}
}
############################# Handle issue with diverging dates ###########################
#fix problem with dates (whether entry belongs to pre- or peri-intervention phase)
error_demo <- ddply(data[which(data$subject=="s3"),],
.(subject, id, phase, block, mindcog_db_date, recordedStart, recordedEnd,
baselineStart, baselineEnd, interventionStart, interventionEnd), plyr::summarise,
nEntries <- length(subject))
View(data[pre_to_peri,])
data[pre_to_peri,]$phase <- "peri"
for(row in 1:nrow(data[pre_to_peri,])){
if((grepl("m1", data$id[row], fixed=TRUE))){
print(TRUE)
data$id[row] <- sub("m1", "\\m2", data$id[row])
}
if((grepl("m3", data$id[row], fixed=TRUE))){
data$id[row] <- sub("m3", "\\m4", data$id[row])
}
}
data[pre_to_peri,]$phase <- "peri"
for(row in 1:nrow(data[pre_to_peri,])){
if((grepl("m1", data$id[row], fixed=TRUE))){
print(TRUE)
data$id[row] <- sub("m1", "\\m2", data$id[row])
}else{
print(FALSE)
}
if((grepl("m3", data$id[row], fixed=TRUE))){
data$id[row] <- sub("m3", "\\m4", data$id[row])
}
}
grepl("m1", data$id[1], fixed = TRUE)
data$id[1]
grepl("m2", data$id[1], fixed = TRUE)
pre_to_peri
data$id[2005]
grepl("m2", data$id[2005], fixed = TRUE)
grepl("m1", data$id[2005], fixed = TRUE)
data[pre_to_peri,]$phase <- "peri"
for(row in pre_to_peri){
if((grepl("m1", data$id[row], fixed=TRUE))){
print(TRUE)
data$id[row] <- sub("m1", "\\m2", data$id[row])
}else{
print(FALSE)
}
if((grepl("m3", data$id[row], fixed=TRUE))){
data$id[row] <- sub("m3", "\\m4", data$id[row])
}
}
View(data[pre_to_peri,])
data[peri_to_pre,]$phase <- "pre"
for(row in peri_to_pre){
if((grepl("m2", data$id[row], fixed=TRUE))){
data$id[row] <- sub("m2", "\\m1", data$id[row])
}
if((grepl("m4", data$id[row], fixed=TRUE))){
data$id[row] <- sub("m4", "\\m3", data$id[row])
}
}
View(data[peri_to_pre,])
pre_to_peri <- c() #empty lists for row indices of faulty entries
peri_to_pre <- c()
i <- 1 #to add to the lists (in a computationally efficient way)
j <- 1
for(row in 1:nrow(data)){
#if there is a date in baselineStart (which means there is one in the other relevant columns too)
# and if it is not a non-response
if((!is.na(data$baselineStart[row])) & (!is.na(data$mindcog_db_date[row]))){
#if phase is "pre"
if((!is.na(data$phase[row])) & (data$phase[row] == "pre")){
#if the recorded mindcog date is greater than the end of baseline date
if((data$mindcog_db_date[row] > data$baselineEnd[row])){
pre_to_peri[i] <- row #add row index to list
i <- i+1 #increment list index count
}
} #same for entries coded as peri that should be pre
if((!is.na(data$phase[row])) & (data$phase[row] == "peri")){
if((data$mindcog_db_date[row] < data$interventionStart[row])){
peri_to_pre[j] <- row
j <- j+1
}
}
}
}
pre_to_peri
peri_to_pre
source("~/Documents/RUG/Thesis/EMA-mindfulness/Data/preprocessing copy.R", echo=TRUE)
View(data)
columnNames
data <- data %>% select(patient_id, id, subject, group, intervention, phase, block,
#18 = db_open_from; 23 = db_date; 26:61 = firstEntry:comments; 67:76
columnNames[18:23], columnNames[26:61],
#67:78 = response measures
columnNames[74:82])
# data <- subset(data, select = -c(roqua_id, hide_pii_from_researchers, gender, birth_year,
#                                  hide_values_from_professionals, respondent_label, respondent_type,
#                                  mindcog_db_project, mindcog_db_notes, mindcog_db_location,
#                                  mindcog_db_invited_at, mindcog_db_emailed_at, mindcog_db_variant,
#                                  mindcog_db_anonymous, mindcog_db_protocol, mindcog_db_measurement))
###################################### Creating lagged variables #############################################
#the variables to be lagged
cols <- c('wakeful', 'sad', 'satisfied', 'irritated', 'energetic', 'restless', 'stressed', 'anxious',
'listless', 'thinkingOf', 'worried', 'stickiness', 'thoughtsPleasant', 'thoughtsTime',
'thoughtsValence', 'thoughtsObject', 'distracted', 'restOfDayPos', 'aloneCompany',
'companyPleasant', 'alonePleasant', 'posMax', 'posIntensity', 'negMax', 'negIntensity')
#creating a vector with new "lagged" column names
laggedCols <- c()
for(col in cols) {
laggedCols <- c(laggedCols, paste(col, "lag1", sep = "_"))
}
#adding empty columns with "lagged" names
data[, laggedCols] <- NA
#zipping current and lagged column names for the for loop
colZip <- mapply(c, cols, laggedCols, SIMPLIFY = FALSE)
#for loop to add the lagged values to their corresponding new columns
for(id in subject_IDs){
respondent_rows <- which(data$subject == id) #one respondent at a time
for(col in colZip) { #looping over the zipped column name pairs
prev_value <- NA #previous value starts out as NA for every column
current_day <- 1 #current day at the beginning of every column per respondent is 1
for(row in respondent_rows) { #looping over the rows associated with the current respondent
if(data$assessmentDay[row] == current_day) { #if the assessment day matches the current day
data[row, col[2]] <- prev_value #add the previous value as the value for the lagged column
prev_value <- data[row, col[1]] #update the previous value
} else { #if assessment day and current day do not match
data[row, col[2]] <- NA #then the lagged value should be NA (new day!)
current_day <- data$assessmentDay[row] #update the current day (could also just be +1)
prev_value <- data[row, col[1]] #update previous value
}
}
}
}
############################################ Change scores ####################################################
cols <- c('wakeful', 'sad', 'satisfied', 'irritated', 'energetic', 'restless', 'stressed', 'anxious',
'listless', 'worried', 'stickiness', 'thoughtsPleasant',  'thoughtsObject', 'distracted', 'restOfDayPos',
'companyPleasant', 'alonePleasant', 'posMax', 'posIntensity', 'negMax', 'negIntensity')
#creating a vector with new "lagged" column names
changeCols <- c()
for(col in cols) {
changeCols <- c(changeCols, paste(col, "change", sep = "_"))
}
#adding empty columns with "lagged" names
data[, changeCols] <- NA
#zipping current and lagged column names for the for loop
colZip <- mapply(c, cols, changeCols, SIMPLIFY = FALSE)
#for loop to add the lagged values to their corresponding new columns
for(id in subject_IDs){
respondent_rows <- which(data$subject == id) #one respondent at a time
for(col in colZip) { #looping over the zipped column name pairs
prev_value <- 0
change_score <- NA #previous value starts out as NA for every column
current_day <- 1 #current day at the beginning of every column per respondent is 1
for(row in respondent_rows) { #looping over the rows associated with the current respondent
if(data$assessmentDay[row] == current_day) { #if the assessment day matches the current day
change_score <- data[row, col[1]] - prev_value #calculate next change score
data[row, col[2]] <- change_score #add the change_score as the value for the lagged column
prev_value <- data[row, col[1]] #update the previous value
} else { #if assessment day and current day do not match
data[row, col[2]] <- NA #then the change score should be NA (new day!)
current_day <- data$assessmentDay[row] #update the current day (could also just be +1)
prev_value <- data[row, col[1]] #update previous value
}
}
}
}
# test <- subset(data, select = c(subject, phase, sad, sad_change, assessmentDay))
# View(test)
write.csv(data, "preprocessed_data.csv", row.names = FALSE)
#################################### Set up ####################################
rm(list = ls()) #clean all up
setwd("~/Documents/RUG/Thesis/EMA-mindfulness/Data/ESM/mindcog_v202202-2")
library(readxl)
library(tidyverse)
library(plyr)
library(dplyr)
library(Hmisc)
library(corrplot)
library(data.table)
library(ggplot2)
library(reshape)
library(ggpubr)
library(lubridate)
library(igraph)
library(qgraph)
#read in data
data <- read_csv('preprocessed_data.csv')
View(data)
#recreacting with assessment days per participant
participant_responses <- ddply(data, .(subject), plyr::summarise,
numBeeped = length(mindcog_db_open_from),
noResponse = length(unique(mindcog_db_non_response)),
response = numBeeped - noResponse,
responseRate = round(response/numBeeped,2),
numDays = max(assessmentDay))
View(participant_responses)
#recreacting with assessment days per group
group_responses <- ddply(data, .(group), plyr::summarise,
numBeeped = length(mindcog_db_open_from),
noResponse = length(unique(mindcog_db_non_response)),
response = numBeeped - noResponse,
responseRate = round(response/numBeeped,2),
numDays = max(assessmentDay)) #6% higher response rate in controls
View(group_responses)
#the mean response rate is ~66%
meanResponseRate <- mean(participant_responses$responseRate)
#sd of 20.48
sdResponseRate <- sd(participant_responses$responseRate)
#number of respondents (i.e., participants?) so far
length(unique(data$subject)) #35 associated with a group
################################# load Medoq info and clean up #################################################
#get sheet names
#sheetnames <- excel_sheets('Medoq_informatie_2.xlsx')
mylist <- lapply(excel_sheets('Medoq_informatie_2.xlsx'), read_excel, path = 'Medoq_informatie_2.xlsx')
# name the dataframes
names(mylist) <- c("matchingMindfulness", "matchingFantasizing")
# Bring the dataframes to the global environment
list2env(mylist ,.GlobalEnv)
matchingMindfulness$intervention <- "mindfulness" #add intervention type per sheet
matchingFantasizing$intervention <- "fantasizing"
matchingData <- rbind(matchingMindfulness, matchingFantasizing) #bind into one df
View(matchingData)
#changing column names since spaces lead to weird errors
colnames(matchingData)[c(1,2,4,5,6)] <- c("id", "recordedDates", "meeting_id", "DatesBaseline", "DatesIntervention")
#turn all ids to lower case for easier error handling below
matchingData$id <- tolower(matchingData$id)
#fix various errors in id column
for(row in 1:nrow(matchingData)) { #some "s" are missing
if( ! (grepl("s", matchingData$id[row], fixed=TRUE)) & (!(is.na(matchingData$id[row])))){
matchingData$id[row] <- paste("s", matchingData$id[row], sep = "")
}
if( ! (grepl("_g", matchingData$id[row], fixed=TRUE))){ #some "_" prior to "g" are missing
matchingData$id[row] <- sub("g", "\\1_g", matchingData$id[row])
}
if( ! (grepl("_m", matchingData$id[row], fixed = TRUE))){ #some "_" prior to "m" are missing
matchingData$id[row] <- sub("m", "\\1_m", matchingData$id[row])
}
if( (grepl("meting", matchingData$id[row], fixed = TRUE))){#some had "meting" instead of just "m"
matchingData$id[row] <- sub("meting", "\\1m", matchingData$id[row])
}
}
#changing column names since spaces lead to weird errors
colnames(matchingData)[c(1,2,4,5,6)] <- c("id", "recordedDates", "meeting_id", "DatesBaseline", "DatesIntervention")
#turn all ids to lower case for easier error handling below
matchingData$id <- tolower(matchingData$id)
data$subject <- str_extract(data$id, regex("^[^_]+(?=_)"))
matchingData <- str_extract(matchingData$id, regex("^[^_]+(?=_)"))
matchingData$subject <- str_extract(matchingData$id, regex("^[^_]+(?=_)"))
################################# load Medoq info and clean up #################################################
#get sheet names
#sheetnames <- excel_sheets('Medoq_informatie_2.xlsx')
mylist <- lapply(excel_sheets('Medoq_informatie_2.xlsx'), read_excel, path = 'Medoq_informatie_2.xlsx')
# name the dataframes
names(mylist) <- c("matchingMindfulness", "matchingFantasizing")
# Bring the dataframes to the global environment
list2env(mylist ,.GlobalEnv)
matchingMindfulness$intervention <- "mindfulness" #add intervention type per sheet
matchingFantasizing$intervention <- "fantasizing"
matchingData <- rbind(matchingMindfulness, matchingFantasizing) #bind into one df
#changing column names since spaces lead to weird errors
colnames(matchingData)[c(1,2,4,5,6)] <- c("id", "recordedDates", "meeting_id", "DatesBaseline", "DatesIntervention")
#turn all ids to lower case for easier error handling below
matchingData$id <- tolower(matchingData$id)
#fix various errors in id column
for(row in 1:nrow(matchingData)) { #some "s" are missing
if( ! (grepl("s", matchingData$id[row], fixed=TRUE)) & (!(is.na(matchingData$id[row])))){
matchingData$id[row] <- paste("s", matchingData$id[row], sep = "")
}
if( ! (grepl("_g", matchingData$id[row], fixed=TRUE))){ #some "_" prior to "g" are missing
matchingData$id[row] <- sub("g", "\\1_g", matchingData$id[row])
}
if( ! (grepl("_m", matchingData$id[row], fixed = TRUE))){ #some "_" prior to "m" are missing
matchingData$id[row] <- sub("m", "\\1_m", matchingData$id[row])
}
if( (grepl("meting", matchingData$id[row], fixed = TRUE))){#some had "meting" instead of just "m"
matchingData$id[row] <- sub("meting", "\\1m", matchingData$id[row])
}
}
matchingData$subject <- str_extract(matchingData$id, regex("^[^_]+(?=_)"))
matchingData$subject <- str_extract(matchingData$id, regex("^[^_]+(?=_)"))
length(unique(matchingData$subject))
View(group_responses)
#recreacting with assessment days per group
group_responses <- ddply(data, .(group), plyr::summarise,
nSubj = length(unique(subject))
numBeeped = length(mindcog_db_open_from),
noResponse = length(unique(mindcog_db_non_response)),
response = numBeeped - noResponse,
responseRate = round(response/numBeeped,2),
numDays = max(assessmentDay)) #6% higher response rate in controls
#recreacting with assessment days per group
group_responses <- ddply(data, .(group), plyr::summarise,
nSubj = length(unique(subject)),
numBeeped = length(mindcog_db_open_from),
noResponse = length(unique(mindcog_db_non_response)),
response = numBeeped - noResponse,
responseRate = round(response/numBeeped,2),
numDays = max(assessmentDay)) #6% higher response rate in controls
View(group_responses)
rm(list = ls()) #clean all up
setwd("~/Documents/RUG/Thesis/EMA-mindfulness/Data/SART")
library(readxl)
library(tidyverse)
library(plyr)
library(dplyr)
library(Hmisc)
library(corrplot)
library(data.table)
library(ggplot2)
library(reshape)
library(ggpubr)
library(lubridate)
library(igraph)
library(qgraph)
#read in data
games <- read_csv('SART_games_110422.csv')
numbers <- read_csv('SART_numbers_110422.csv')
questions <- read_csv('SART_questions_110422.csv')
View(games)
View(numbers)
View(questions)
summary(games)
length(games)
length(games$id)
length(numbers$id)
length(questions$id)
length(unique(games$id))
length(unique(numbers$id))
length(unique(questions$id))
length(unique(games$userID))
length(unique(numbers$userID))
length(unique(questions$userID))
length(unique(games$gameSessionID))
games_summary <- ddply(games, .(userID, gameSessionID), plyr::summarise,
nSubj = length(unique(userID)))
View(games_summary)
games_summary <- ddply(games, .(userID), plyr::summarise,
nGames = length(unique(gameSessionID)))
View(games_summary)
################################## Inspecting games ###################################
length(unique(games$userID))
length(unique(games$gameSessionID))
length(games$gameSessionID) #47
################################# Inspecting numbers ##################################
length(unique(numbers$userID))
numbers_summary <- ddply(numbers, .(userID), plyr::summarise,
nGames = length(unique(gameSessionID)),
proportionCorrect = length(correct[which(correct == TRUE)]) / length(correct),
meanRT = mean(responseTime))
View(numbers_summary)
numbers_summary <- ddply(numbers, .(userID), plyr::summarise,
nGames = length(unique(gameSessionID)),
nTrials = length(correct),
proportionCorrect = length(correct[which(correct == TRUE)]) / length(correct),
meanRT = mean(responseTime))
View(numbers_summary)
View(numbers[which(numbers$userID=="148649783"),])
numbers_summary <- ddply(numbers, .(userID), plyr::summarise,
nGames = length(unique(gameSessionID)),
nTrials = length(correct),
proportionCorrect = length(correct[which(correct == TRUE)]) / nTrials,
meanRT = round(mean(responseTime),2))
numbers_summary <- ddply(numbers, .(userID), plyr::summarise,
nGames = length(unique(gameSessionID)),
nTrials = length(correct),
proportionCorrect = round(length(correct[which(correct == TRUE)]) / nTrials,2),
meanRT = round(mean(responseTime),2))
View(numbers_summary)
max(numbers_summary$nTrials)
mean(numbers_summary$nTrials)
################################ Inspecting questions ##################################
length(unique(questions$userID))
questions_summary <- ddply(questions, .(userID), plyr::summarise,
nGames = length(unique(gameSessionID)),
proportionAnswer1 = length(answer[which(answer==1)]),
proportionAnswer2 = length(answer[which(answer==2)]),
proportionAnswer3 = length(answer[which(answer==3)]))
View(questions_summary)
questions_summary <- ddply(questions, .(userID), plyr::summarise,
nGames = length(unique(gameSessionID)),
nQuestions = length(questionID))
View(questions_summary)
questions_summary2 <- ddply(questions, .(questionID), plyr::summarise,
proportionAnswer1 = length(questionID[which(answer==1)]),
proportionAnswer2 = length(questionID[which(answer==2)]),
proportionAnswer3 = length(questionID[which(answer==3)]))
View(questions_summary2)
questions_summary2 <- ddply(questions, .(questionID), plyr::summarise,
proportionAnswer1 = length(questionID[which(answer==1)])/length(questionID),
proportionAnswer2 = length(questionID[which(answer==2)]),
proportionAnswer3 = length(questionID[which(answer==3)]))
View(questions_summary2)
questions_summary2 <- ddply(questions, .(questionID), plyr::summarise,
proportionAnswer1 = length(questionID[which(answer==1)])/length(questionID),
proportionAnswer2 = length(questionID[which(answer==2)])/length(questionID),
proportionAnswer3 = length(questionID[which(answer==3)])/length(questionID))
questions_summary2 <- ddply(questions, .(questionID), plyr::summarise,
proportionAnswer0 = length(questionID[which(answer==0)])/length(questionID),
proportionAnswer1 = length(questionID[which(answer==1)])/length(questionID),
proportionAnswer2 = length(questionID[which(answer==2)])/length(questionID),
proportionAnswer3 = length(questionID[which(answer==3)])/length(questionID))
proportionAnswer3 = round(length(questionID[which(answer==3)])/length(questionID),2)
questions_summary2 <- ddply(questions, .(questionID), plyr::summarise,
questions_summary2 <- ddply(questions, .(questionID), plyr::summarise,
proportionAnswer0 = round(length(questionID[which(answer==0)])/length(questionID),2),
proportionAnswer1 = round(length(questionID[which(answer==1)])/length(questionID),2),
proportionAnswer2 = round(length(questionID[which(answer==2)])/length(questionID),2),
proportionAnswer3 = round(length(questionID[which(answer==3)])/length(questionID),2))
+
d
)
questions_summary2 <- ddply(questions, .(questionID), plyr::summarise,
proportionAnswer0 = round(length(questionID[which(answer==0)])/length(questionID),2),
proportionAnswer1 = round(length(questionID[which(answer==1)])/length(questionID),2),
proportionAnswer2 = round(length(questionID[which(answer==2)])/length(questionID),2),
proportionAnswer3 = round(length(questionID[which(answer==3)])/length(questionID),2))
questions_summary2 <- ddply(questions, .(questionID), plyr::summarise,
proportionAnswer0 = round(length(questionID[which(answer==0)])/length(questionID),2),
proportionAnswer1 = round(length(questionID[which(answer==1)])/length(questionID),2),
proportionAnswer2 = round(length(questionID[which(answer==2)])/length(questionID),2),
proportionAnswer3 = round(length(questionID[which(answer==3)])/length(questionID),2))
questions_summary2 <- ddply(questions, .(questionID), plyr::summarise,
proportionAnswer0 = round(length(questionID[which(answer==0)])/length(questionID),2),
proportionAnswer1 = round(length(questionID[which(answer==1)])/length(questionID),2),
proportionAnswer2 = round(length(questionID[which(answer==2)])/length(questionID),2),
proportionAnswer3 = round(length(questionID[which(answer==3)])/length(questionID),2))
View(questions_summary2)
unique(questions$answer)
questions_summary2 <- ddply(questions, .(questionID), plyr::summarise,
proportionAnswer0 = round(length(questionID[which(answer==0)])/length(questionID),2),
proportionAnswer1 = round(length(questionID[which(answer==1)])/length(questionID),2),
proportionAnswer2 = round(length(questionID[which(answer==2)])/length(questionID),2),
proportionAnswer3 = round(length(questionID[which(answer==3)])/length(questionID),2),
proportionAnswer4 = round(length(questionID[which(answer==4)])/length(questionID),2),
proportionAnswer5 = round(length(questionID[which(answer==5)])/length(questionID),2))
View(questions_summary2)
